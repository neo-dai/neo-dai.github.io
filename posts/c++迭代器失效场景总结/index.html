<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++迭代器失效场景总结 | Notes</title><meta name=keywords content="c++"><meta name=description content='目录

1. 什么是迭代器失效
2. vector的迭代器失效
3. deque的迭代器失效
4. list的迭代器失效
5. map/set的迭代器失效
6. unordered_map/unordered_set的迭代器失效
7. 迭代器失效的预防措施
8. 总结表格


1. 什么是迭代器失效
迭代器失效是指当容器的内部结构发生改变时，原有的迭代器可能变得不再有效，继续使用会导致未定义行为，包括程序崩溃、数据错误等。
迭代器失效的主要原因：

容器扩容（导致内存重新分配）
元素插入/删除（改变容器内部结构）
容器被移动或销毁


2. vector的迭代器失效
2.1 插入操作导致失效
场景1：push_back导致扩容
#include <vector>
#include <iostream>

void example_vector_pushback() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    vec.reserve(5);  // 容量为5
    
    auto it = vec.begin();
    auto it_mid = vec.begin() + 2;  // 指向第3个元素
    
    std::cout << "扩容前: *it_mid = " << *it_mid << std::endl;  // 输出: 3
    
    vec.push_back(6);  // 触发扩容！
    
    // ❌ 危险！it和it_mid已经失效
    // std::cout << *it_mid << std::endl;  // 未定义行为
}
失效原因：

push_back导致vector扩容时，会重新分配内存
所有元素被复制到新的内存位置
所有迭代器、指针、引用全部失效


场景2：insert操作
void example_vector_insert() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    auto it = vec.begin() + 2;  // 指向值为3的元素
    
    // 在位置1插入元素
    vec.insert(vec.begin() + 1, 99);
    
    // ❌ it已经失效！
    // 即使没有扩容，insert之后的所有迭代器都会失效
}
失效规则：'><meta name=author content="neo"><link rel=canonical href=https://neo-dai.github.io/posts/c++%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/><link crossorigin=anonymous href=/assets/css/stylesheet.b4dfb58bc1aadc21cb0542f53df82233971252c1283b7ff385ac519b35b25bc3.css integrity="sha256-tN+1i8Gq3CHLBUL1PfgiM5cSUsEoO3/zhaxRmzWyW8M=" rel="preload stylesheet" as=style><link rel=icon href=https://neo-dai.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://neo-dai.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://neo-dai.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://neo-dai.github.io/apple-touch-icon.png><link rel=mask-icon href=https://neo-dai.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://neo-dai.github.io/posts/c++%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500;600;700&display=swap" rel=stylesheet><meta property="og:url" content="https://neo-dai.github.io/posts/c++%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="Notes"><meta property="og:title" content="C++迭代器失效场景总结"><meta property="og:description" content='目录 1. 什么是迭代器失效 2. vector的迭代器失效 3. deque的迭代器失效 4. list的迭代器失效 5. map/set的迭代器失效 6. unordered_map/unordered_set的迭代器失效 7. 迭代器失效的预防措施 8. 总结表格 1. 什么是迭代器失效 迭代器失效是指当容器的内部结构发生改变时，原有的迭代器可能变得不再有效，继续使用会导致未定义行为，包括程序崩溃、数据错误等。
迭代器失效的主要原因：
容器扩容（导致内存重新分配） 元素插入/删除（改变容器内部结构） 容器被移动或销毁 2. vector的迭代器失效 2.1 插入操作导致失效 场景1：push_back导致扩容
#include <vector> #include <iostream> void example_vector_pushback() { std::vector<int> vec = {1, 2, 3, 4, 5}; vec.reserve(5); // 容量为5 auto it = vec.begin(); auto it_mid = vec.begin() + 2; // 指向第3个元素 std::cout << "扩容前: *it_mid = " << *it_mid << std::endl; // 输出: 3 vec.push_back(6); // 触发扩容！ // ❌ 危险！it和it_mid已经失效 // std::cout << *it_mid << std::endl; // 未定义行为 } 失效原因：
push_back导致vector扩容时，会重新分配内存 所有元素被复制到新的内存位置 所有迭代器、指针、引用全部失效 场景2：insert操作
void example_vector_insert() { std::vector<int> vec = {1, 2, 3, 4, 5}; auto it = vec.begin() + 2; // 指向值为3的元素 // 在位置1插入元素 vec.insert(vec.begin() + 1, 99); // ❌ it已经失效！ // 即使没有扩容，insert之后的所有迭代器都会失效 } 失效规则：'><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-11T17:27:25+08:00"><meta property="article:modified_time" content="2025-12-11T17:27:25+08:00"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++迭代器失效场景总结"><meta name=twitter:description content='目录

1. 什么是迭代器失效
2. vector的迭代器失效
3. deque的迭代器失效
4. list的迭代器失效
5. map/set的迭代器失效
6. unordered_map/unordered_set的迭代器失效
7. 迭代器失效的预防措施
8. 总结表格


1. 什么是迭代器失效
迭代器失效是指当容器的内部结构发生改变时，原有的迭代器可能变得不再有效，继续使用会导致未定义行为，包括程序崩溃、数据错误等。
迭代器失效的主要原因：

容器扩容（导致内存重新分配）
元素插入/删除（改变容器内部结构）
容器被移动或销毁


2. vector的迭代器失效
2.1 插入操作导致失效
场景1：push_back导致扩容
#include <vector>
#include <iostream>

void example_vector_pushback() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    vec.reserve(5);  // 容量为5
    
    auto it = vec.begin();
    auto it_mid = vec.begin() + 2;  // 指向第3个元素
    
    std::cout << "扩容前: *it_mid = " << *it_mid << std::endl;  // 输出: 3
    
    vec.push_back(6);  // 触发扩容！
    
    // ❌ 危险！it和it_mid已经失效
    // std::cout << *it_mid << std::endl;  // 未定义行为
}
失效原因：

push_back导致vector扩容时，会重新分配内存
所有元素被复制到新的内存位置
所有迭代器、指针、引用全部失效


场景2：insert操作
void example_vector_insert() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    auto it = vec.begin() + 2;  // 指向值为3的元素
    
    // 在位置1插入元素
    vec.insert(vec.begin() + 1, 99);
    
    // ❌ it已经失效！
    // 即使没有扩容，insert之后的所有迭代器都会失效
}
失效规则：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://neo-dai.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++迭代器失效场景总结","item":"https://neo-dai.github.io/posts/c++%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++迭代器失效场景总结","name":"C\u002b\u002b迭代器失效场景总结","description":"目录 1. 什么是迭代器失效 2. vector的迭代器失效 3. deque的迭代器失效 4. list的迭代器失效 5. map/set的迭代器失效 6. unordered_map/unordered_set的迭代器失效 7. 迭代器失效的预防措施 8. 总结表格 1. 什么是迭代器失效 迭代器失效是指当容器的内部结构发生改变时，原有的迭代器可能变得不再有效，继续使用会导致未定义行为，包括程序崩溃、数据错误等。\n迭代器失效的主要原因：\n容器扩容（导致内存重新分配） 元素插入/删除（改变容器内部结构） 容器被移动或销毁 2. vector的迭代器失效 2.1 插入操作导致失效 场景1：push_back导致扩容\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; void example_vector_pushback() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; vec.reserve(5); // 容量为5 auto it = vec.begin(); auto it_mid = vec.begin() + 2; // 指向第3个元素 std::cout \u0026lt;\u0026lt; \u0026#34;扩容前: *it_mid = \u0026#34; \u0026lt;\u0026lt; *it_mid \u0026lt;\u0026lt; std::endl; // 输出: 3 vec.push_back(6); // 触发扩容！ // ❌ 危险！it和it_mid已经失效 // std::cout \u0026lt;\u0026lt; *it_mid \u0026lt;\u0026lt; std::endl; // 未定义行为 } 失效原因：\npush_back导致vector扩容时，会重新分配内存 所有元素被复制到新的内存位置 所有迭代器、指针、引用全部失效 场景2：insert操作\nvoid example_vector_insert() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; auto it = vec.begin() + 2; // 指向值为3的元素 // 在位置1插入元素 vec.insert(vec.begin() + 1, 99); // ❌ it已经失效！ // 即使没有扩容，insert之后的所有迭代器都会失效 } 失效规则：\n","keywords":["c++"],"articleBody":"目录 1. 什么是迭代器失效 2. vector的迭代器失效 3. deque的迭代器失效 4. list的迭代器失效 5. map/set的迭代器失效 6. unordered_map/unordered_set的迭代器失效 7. 迭代器失效的预防措施 8. 总结表格 1. 什么是迭代器失效 迭代器失效是指当容器的内部结构发生改变时，原有的迭代器可能变得不再有效，继续使用会导致未定义行为，包括程序崩溃、数据错误等。\n迭代器失效的主要原因：\n容器扩容（导致内存重新分配） 元素插入/删除（改变容器内部结构） 容器被移动或销毁 2. vector的迭代器失效 2.1 插入操作导致失效 场景1：push_back导致扩容\n#include #include void example_vector_pushback() { std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; vec.reserve(5); // 容量为5 auto it = vec.begin(); auto it_mid = vec.begin() + 2; // 指向第3个元素 std::cout \u003c\u003c \"扩容前: *it_mid = \" \u003c\u003c *it_mid \u003c\u003c std::endl; // 输出: 3 vec.push_back(6); // 触发扩容！ // ❌ 危险！it和it_mid已经失效 // std::cout \u003c\u003c *it_mid \u003c\u003c std::endl; // 未定义行为 } 失效原因：\npush_back导致vector扩容时，会重新分配内存 所有元素被复制到新的内存位置 所有迭代器、指针、引用全部失效 场景2：insert操作\nvoid example_vector_insert() { std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; auto it = vec.begin() + 2; // 指向值为3的元素 // 在位置1插入元素 vec.insert(vec.begin() + 1, 99); // ❌ it已经失效！ // 即使没有扩容，insert之后的所有迭代器都会失效 } 失效规则：\n如果插入导致扩容：所有迭代器失效 如果没有扩容：插入点之后（包括插入点）的迭代器失效，插入点之前的仍有效 正确做法：\nvoid correct_vector_insert() { std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; auto it = vec.begin() + 2; // insert返回指向新插入元素的迭代器 it = vec.insert(it, 99); // ✅ 更新迭代器 std::cout \u003c\u003c *it \u003c\u003c std::endl; // 输出: 99 } 2.2 删除操作导致失效 场景1：erase单个元素\nvoid example_vector_erase() { std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; auto it = vec.begin() + 2; // 指向3 vec.erase(it); // 删除3 // ❌ it已经失效！ // std::cout \u003c\u003c *it \u003c\u003c std::endl; // 未定义行为 } 失效规则：\n被删除元素的迭代器失效 删除点之后的所有迭代器失效 删除点之前的迭代器仍然有效 正确做法：\nvoid correct_vector_erase() { std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; auto it = vec.begin(); while (it != vec.end()) { if (*it % 2 == 0) { it = vec.erase(it); // ✅ erase返回下一个有效迭代器 } else { ++it; } } // vec现在是 {1, 3, 5} } 场景2：删除所有偶数（错误示范）\nvoid wrong_erase_loop() { std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5, 6}; // ❌ 错误的删除方式 for (auto it = vec.begin(); it != vec.end(); ++it) { if (*it % 2 == 0) { vec.erase(it); // it失效，++it是未定义行为！ } } } 2.3 其他导致失效的操作 void other_invalidate_operations() { std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; auto it = vec.begin(); // clear清空容器 vec.clear(); // ❌ 所有迭代器失效 // resize改变大小 vec = {1, 2, 3, 4, 5}; it = vec.begin(); vec.resize(10); // ❌ 可能扩容，所有迭代器可能失效 // reserve增加容量 vec.reserve(100); // ❌ 扩容，所有迭代器失效 // swap交换容器 std::vector\u003cint\u003e vec2 = {10, 20, 30}; vec.swap(vec2); // ❌ 两个容器的迭代器都失效（或互换） } 3. deque的迭代器失效 3.1 插入操作 #include void example_deque_insert() { std::deque\u003cint\u003e dq = {1, 2, 3, 4, 5}; auto it = dq.begin() + 2; // 在首尾插入 dq.push_front(0); // ❌ 所有迭代器失效（但引用和指针仍有效） dq.push_back(6); // ❌ 所有迭代器失效（但引用和指针仍有效） // 在中间插入 it = dq.begin() + 3; dq.insert(it, 99); // ❌ 所有迭代器、引用、指针全部失效 } 失效规则：\n首尾插入（push_front/push_back）：所有迭代器失效，但引用和指针仍有效 中间插入：所有迭代器、引用、指针全部失效 3.2 删除操作 void example_deque_erase() { std::deque\u003cint\u003e dq = {1, 2, 3, 4, 5}; auto it = dq.begin() + 2; // 删除首尾元素 dq.pop_front(); // ❌ 只有首元素的迭代器失效，其他有效 dq.pop_back(); // ❌ 只有尾元素的迭代器失效，其他有效 // 删除中间元素 it = dq.begin() + 1; dq.erase(it); // ❌ 所有迭代器、引用、指针全部失效 } 失效规则：\n首尾删除：只有被删除元素的迭代器失效 中间删除：所有迭代器、引用、指针全部失效 4. list的迭代器失效 list是双向链表，迭代器失效情况相对简单。\n4.1 插入操作 #include void example_list_insert() { std::list\u003cint\u003e lst = {1, 2, 3, 4, 5}; auto it = lst.begin(); ++it; // 指向2 lst.push_front(0); // ✅ 所有迭代器仍有效 lst.push_back(6); // ✅ 所有迭代器仍有效 lst.insert(it, 99); // ✅ 所有迭代器仍有效 } 失效规则：\n插入操作不会导致任何迭代器失效 4.2 删除操作 void example_list_erase() { std::list\u003cint\u003e lst = {1, 2, 3, 4, 5}; auto it1 = lst.begin(); auto it2 = ++lst.begin(); auto it3 = ++(++lst.begin()); lst.erase(it2); // ❌ 只有it2失效，it1和it3仍有效 std::cout \u003c\u003c *it1 \u003c\u003c std::endl; // ✅ 输出: 1 std::cout \u003c\u003c *it3 \u003c\u003c std::endl; // ✅ 输出: 3 } 失效规则：\n删除操作只会使被删除元素的迭代器失效 其他迭代器不受影响 正确的删除循环：\nvoid correct_list_erase() { std::list\u003cint\u003e lst = {1, 2, 3, 4, 5, 6}; auto it = lst.begin(); while (it != lst.end()) { if (*it % 2 == 0) { it = lst.erase(it); // ✅ 返回下一个有效迭代器 } else { ++it; } } // lst现在是 {1, 3, 5} } 5. map/set的迭代器失效 map、set、multimap、multiset底层是红黑树。\n5.1 插入操作 #include #include void example_map_insert() { std::map\u003cint, std::string\u003e m = {{1, \"one\"}, {2, \"two\"}, {3, \"three\"}}; auto it = m.begin(); m.insert({4, \"four\"}); // ✅ 所有迭代器仍有效 m[5] = \"five\"; // ✅ 所有迭代器仍有效 } 失效规则：\n插入操作不会导致任何迭代器失效 5.2 删除操作 void example_map_erase() { std::map\u003cint, std::string\u003e m = { {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"} }; auto it1 = m.begin(); // 指向{1, \"one\"} auto it2 = ++m.begin(); // 指向{2, \"two\"} auto it3 = ++(++m.begin()); // 指向{3, \"three\"} m.erase(it2); // ❌ 只有it2失效，it1和it3仍有效 std::cout \u003c\u003c it1-\u003efirst \u003c\u003c std::endl; // ✅ 输出: 1 std::cout \u003c\u003c it3-\u003efirst \u003c\u003c std::endl; // ✅ 输出: 3 // std::cout \u003c\u003c it2-\u003efirst \u003c\u003c std::endl; // ❌ 未定义行为 } 失效规则：\n删除操作只会使被删除元素的迭代器失效 其他迭代器不受影响 正确的删除循环：\nvoid correct_map_erase() { std::map\u003cint, std::string\u003e m = { {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"} }; // C++11以后，erase返回下一个有效迭代器 auto it = m.begin(); while (it != m.end()) { if (it-\u003efirst % 2 == 0) { it = m.erase(it); // ✅ C++11 } else { ++it; } } // C++11之前的写法 for (auto it = m.begin(); it != m.end(); ) { if (it-\u003efirst % 2 == 0) { m.erase(it++); // ✅ 先拷贝it，再递增，然后删除拷贝的it } else { ++it; } } } 6. unordered_map/unordered_set的迭代器失效 unordered_map、unordered_set底层是哈希表。\n6.1 插入操作 #include void example_unordered_map_insert() { std::unordered_map\u003cint, std::string\u003e um = { {1, \"one\"}, {2, \"two\"}, {3, \"three\"} }; auto it = um.begin(); // 如果插入导致rehash（负载因子超过阈值） um.insert({4, \"four\"}); // ⚠️ 可能触发rehash，所有迭代器失效 } 失效规则：\n如果插入导致rehash：所有迭代器失效（但引用和指针仍有效） 如果没有rehash：所有迭代器仍有效 检查是否会rehash：\nvoid check_rehash() { std::unordered_map\u003cint, std::string\u003e um; um.reserve(10); // 预留空间，避免频繁rehash std::cout \u003c\u003c \"bucket_count: \" \u003c\u003c um.bucket_count() \u003c\u003c std::endl; std::cout \u003c\u003c \"load_factor: \" \u003c\u003c um.load_factor() \u003c\u003c std::endl; std::cout \u003c\u003c \"max_load_factor: \" \u003c\u003c um.max_load_factor() \u003c\u003c std::endl; // 插入前检查 if (um.size() + 1 \u003e um.bucket_count() * um.max_load_factor()) { std::cout \u003c\u003c \"下次插入将触发rehash！\" \u003c\u003c std::endl; } } 6.2 删除操作 void example_unordered_map_erase() { std::unordered_map\u003cint, std::string\u003e um = { {1, \"one\"}, {2, \"two\"}, {3, \"three\"} }; auto it1 = um.begin(); auto it2 = ++um.begin(); um.erase(it1); // ❌ 只有it1失效，it2仍有效 } 失效规则：\n删除操作只会使被删除元素的迭代器失效 其他迭代器不受影响 7. 迭代器失效的预防措施 7.1 使用返回的迭代器 // ✅ 始终使用insert/erase返回的迭代器 it = vec.insert(it, value); it = vec.erase(it); 7.2 预分配空间 // ✅ 避免频繁扩容 std::vector\u003cint\u003e vec; vec.reserve(1000); // 预留空间 std::unordered_map\u003cint, int\u003e um; um.reserve(1000); // 预留空间，避免rehash 7.3 使用索引代替迭代器 // ✅ 在vector中，索引不会失效 std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; for (size_t i = 0; i \u003c vec.size(); ) { if (vec[i] % 2 == 0) { vec.erase(vec.begin() + i); // 不需要i++，因为后面的元素会前移 } else { ++i; } } 7.4 使用remove-erase惯用法 #include // ✅ 对于vector，使用remove-erase惯用法更安全 std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5, 6}; vec.erase( std::remove_if(vec.begin(), vec.end(), [](int x) { return x % 2 == 0; }), vec.end() ); 7.5 选择合适的容器 // 如果需要频繁插入删除，考虑使用list std::list\u003cint\u003e lst = {1, 2, 3, 4, 5}; // list的迭代器更稳定 // 如果需要稳定的迭代器且查找性能重要，考虑map/set std::map\u003cint, std::string\u003e m; // 插入不会导致迭代器失效 8. 总结表格 容器类型 插入操作 删除操作 vector 扩容时全部失效\n不扩容时插入点及之后失效 删除点及之后失效 deque 首尾插入：所有迭代器失效\n中间插入：全部失效 首尾删除：仅被删除元素失效\n中间删除：全部失效 list 不会失效 仅被删除元素失效 map/set 不会失效 仅被删除元素失效 unordered_map\nunordered_set rehash时全部失效\n否则不失效 仅被删除元素失效 关键要点 vector和deque最容易出现迭代器失效 list、map/set的迭代器相对稳定 unordered容器需要注意rehash 删除和插入操作后，始终使用返回的迭代器 尽量使用STL算法（如remove_if）而不是手动循环删除 预分配空间可以避免很多问题 调试技巧 编译器选项：使用-D_GLIBCXX_DEBUG（GCC）或类似选项开启调试模式 AddressSanitizer：使用-fsanitize=address检测内存错误 静态分析工具：使用clang-tidy等工具 单元测试：为容器操作编写单元测试 # 编译时开启调试选项 g++ -std=c++17 -D_GLIBCXX_DEBUG -fsanitize=address -g main.cpp -o main 参考资料：\nC++ Reference: https://en.cppreference.com/ Effective STL by Scott Meyers C++ Primer 5th Edition ","wordCount":"1076","inLanguage":"en","datePublished":"2025-12-11T17:27:25+08:00","dateModified":"2025-12-11T17:27:25+08:00","author":{"@type":"Person","name":"neo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://neo-dai.github.io/posts/c++%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/"},"publisher":{"@type":"Organization","name":"Notes","logo":{"@type":"ImageObject","url":"https://neo-dai.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://neo-dai.github.io/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://neo-dai.github.io/ title=首页><span>首页</span></a></li><li><a href=https://neo-dai.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://neo-dai.github.io/series/ title=专栏><span>专栏</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">C++迭代器失效场景总结</h1><div class=post-meta><span title='2025-12-11 17:27:25 +0800 +0800'>2025年12月11日</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>neo</span></div></header><div class=post-content><h2 id=目录>目录<a hidden class=anchor aria-hidden=true href=#目录>#</a></h2><ul><li><a href=#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88>1. 什么是迭代器失效</a></li><li><a href=#2-vector%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88>2. vector的迭代器失效</a></li><li><a href=#3-deque%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88>3. deque的迭代器失效</a></li><li><a href=#4-list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88>4. list的迭代器失效</a></li><li><a href=#5-mapset%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88>5. map/set的迭代器失效</a></li><li><a href=#6-unordered_mapunordered_set%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88>6. unordered_map/unordered_set的迭代器失效</a></li><li><a href=#7-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E9%A2%84%E9%98%B2%E6%8E%AA%E6%96%BD>7. 迭代器失效的预防措施</a></li><li><a href=#8-%E6%80%BB%E7%BB%93%E8%A1%A8%E6%A0%BC>8. 总结表格</a></li></ul><hr><h2 id=1-什么是迭代器失效>1. 什么是迭代器失效<a hidden class=anchor aria-hidden=true href=#1-什么是迭代器失效>#</a></h2><p><strong>迭代器失效</strong>是指当容器的内部结构发生改变时，原有的迭代器可能变得不再有效，继续使用会导致<strong>未定义行为</strong>，包括程序崩溃、数据错误等。</p><p>迭代器失效的主要原因：</p><ul><li><strong>容器扩容</strong>（导致内存重新分配）</li><li><strong>元素插入/删除</strong>（改变容器内部结构）</li><li><strong>容器被移动或销毁</strong></li></ul><hr><h2 id=2-vector的迭代器失效>2. vector的迭代器失效<a hidden class=anchor aria-hidden=true href=#2-vector的迭代器失效>#</a></h2><h3 id=21-插入操作导致失效>2.1 插入操作导致失效<a hidden class=anchor aria-hidden=true href=#21-插入操作导致失效>#</a></h3><p><strong>场景1：push_back导致扩容</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>example_vector_pushback</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>vec</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>  <span class=c1>// 容量为5
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it_mid</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// 指向第3个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;扩容前: *it_mid = &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>it_mid</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// 输出: 3
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>vec</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span>  <span class=c1>// 触发扩容！
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// ❌ 危险！it和it_mid已经失效
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// std::cout &lt;&lt; *it_mid &lt;&lt; std::endl;  // 未定义行为
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>失效原因</strong>：</p><ul><li><code>push_back</code>导致vector扩容时，会重新分配内存</li><li>所有元素被复制到新的内存位置</li><li>所有迭代器、指针、引用全部失效</li></ul><hr><p><strong>场景2：insert操作</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>example_vector_insert</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// 指向值为3的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// 在位置1插入元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vec</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>99</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// ❌ it已经失效！
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 即使没有扩容，insert之后的所有迭代器都会失效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>失效规则</strong>：</p><ul><li>如果<strong>插入导致扩容</strong>：所有迭代器失效</li><li>如果<strong>没有扩容</strong>：插入点之后（包括插入点）的迭代器失效，插入点之前的仍有效</li></ul><p><strong>正确做法</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>correct_vector_insert</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// insert返回指向新插入元素的迭代器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>it</span><span class=p>,</span> <span class=mi>99</span><span class=p>);</span>  <span class=c1>// ✅ 更新迭代器
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>it</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// 输出: 99
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><hr><h3 id=22-删除操作导致失效>2.2 删除操作导致失效<a hidden class=anchor aria-hidden=true href=#22-删除操作导致失效>#</a></h3><p><strong>场景1：erase单个元素</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>example_vector_erase</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// 指向3
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>vec</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>  <span class=c1>// 删除3
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// ❌ it已经失效！
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 未定义行为
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>失效规则</strong>：</p><ul><li>被删除元素的迭代器失效</li><li>删除点之后的所有迭代器失效</li><li>删除点之前的迭代器仍然有效</li></ul><p><strong>正确做法</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>correct_vector_erase</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>it</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>  <span class=c1>// ✅ erase返回下一个有效迭代器
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// vec现在是 {1, 3, 5}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><hr><p><strong>场景2：删除所有偶数（错误示范）</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>wrong_erase_loop</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// ❌ 错误的删除方式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>it</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>vec</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>  <span class=c1>// it失效，++it是未定义行为！
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h3 id=23-其他导致失效的操作>2.3 其他导致失效的操作<a hidden class=anchor aria-hidden=true href=#23-其他导致失效的操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>other_invalidate_operations</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// clear清空容器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vec</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>  <span class=c1>// ❌ 所有迭代器失效
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// resize改变大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>vec</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>  <span class=c1>// ❌ 可能扩容，所有迭代器可能失效
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// reserve增加容量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vec</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>  <span class=c1>// ❌ 扩容，所有迭代器失效
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// swap交换容器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec2</span> <span class=o>=</span> <span class=p>{</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>30</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>vec</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>vec2</span><span class=p>);</span>  <span class=c1>// ❌ 两个容器的迭代器都失效（或互换）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=3-deque的迭代器失效>3. deque的迭代器失效<a hidden class=anchor aria-hidden=true href=#3-deque的迭代器失效>#</a></h2><h3 id=31-插入操作>3.1 插入操作<a hidden class=anchor aria-hidden=true href=#31-插入操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;deque&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>example_deque_insert</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>deque</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dq</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>dq</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 在首尾插入
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dq</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>   <span class=c1>// ❌ 所有迭代器失效（但引用和指针仍有效）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dq</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span>    <span class=c1>// ❌ 所有迭代器失效（但引用和指针仍有效）
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// 在中间插入
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>it</span> <span class=o>=</span> <span class=n>dq</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>dq</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>it</span><span class=p>,</span> <span class=mi>99</span><span class=p>);</span>  <span class=c1>// ❌ 所有迭代器、引用、指针全部失效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>失效规则</strong>：</p><ul><li><strong>首尾插入</strong>（<code>push_front</code>/<code>push_back</code>）：所有迭代器失效，但引用和指针仍有效</li><li><strong>中间插入</strong>：所有迭代器、引用、指针全部失效</li></ul><hr><h3 id=32-删除操作>3.2 删除操作<a hidden class=anchor aria-hidden=true href=#32-删除操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>example_deque_erase</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>deque</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dq</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>dq</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 删除首尾元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dq</span><span class=p>.</span><span class=n>pop_front</span><span class=p>();</span>  <span class=c1>// ❌ 只有首元素的迭代器失效，其他有效
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dq</span><span class=p>.</span><span class=n>pop_back</span><span class=p>();</span>   <span class=c1>// ❌ 只有尾元素的迭代器失效，其他有效
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// 删除中间元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>it</span> <span class=o>=</span> <span class=n>dq</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>dq</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>    <span class=c1>// ❌ 所有迭代器、引用、指针全部失效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>失效规则</strong>：</p><ul><li><strong>首尾删除</strong>：只有被删除元素的迭代器失效</li><li><strong>中间删除</strong>：所有迭代器、引用、指针全部失效</li></ul><hr><h2 id=4-list的迭代器失效>4. list的迭代器失效<a hidden class=anchor aria-hidden=true href=#4-list的迭代器失效>#</a></h2><p><code>list</code>是双向链表，迭代器失效情况相对简单。</p><h3 id=41-插入操作>4.1 插入操作<a hidden class=anchor aria-hidden=true href=#41-插入操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;list&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>example_list_insert</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>lst</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>lst</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>it</span><span class=p>;</span>  <span class=c1>// 指向2
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>lst</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>   <span class=c1>// ✅ 所有迭代器仍有效
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lst</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span>    <span class=c1>// ✅ 所有迭代器仍有效
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lst</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>it</span><span class=p>,</span> <span class=mi>99</span><span class=p>);</span>  <span class=c1>// ✅ 所有迭代器仍有效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>失效规则</strong>：</p><ul><li>插入操作<strong>不会</strong>导致任何迭代器失效</li></ul><hr><h3 id=42-删除操作>4.2 删除操作<a hidden class=anchor aria-hidden=true href=#42-删除操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>example_list_erase</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>lst</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it1</span> <span class=o>=</span> <span class=n>lst</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it2</span> <span class=o>=</span> <span class=o>++</span><span class=n>lst</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it3</span> <span class=o>=</span> <span class=o>++</span><span class=p>(</span><span class=o>++</span><span class=n>lst</span><span class=p>.</span><span class=n>begin</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>lst</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it2</span><span class=p>);</span>  <span class=c1>// ❌ 只有it2失效，it1和it3仍有效
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>it1</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// ✅ 输出: 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>it3</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// ✅ 输出: 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>失效规则</strong>：</p><ul><li>删除操作<strong>只会</strong>使被删除元素的迭代器失效</li><li>其他迭代器不受影响</li></ul><p><strong>正确的删除循环</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>correct_list_erase</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>lst</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>lst</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>lst</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>it</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>it</span> <span class=o>=</span> <span class=n>lst</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>  <span class=c1>// ✅ 返回下一个有效迭代器
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// lst现在是 {1, 3, 5}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=5-mapset的迭代器失效>5. map/set的迭代器失效<a hidden class=anchor aria-hidden=true href=#5-mapset的迭代器失效>#</a></h2><p><code>map</code>、<code>set</code>、<code>multimap</code>、<code>multiset</code>底层是<strong>红黑树</strong>。</p><h3 id=51-插入操作>5.1 插入操作<a hidden class=anchor aria-hidden=true href=#51-插入操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;map&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;set&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>example_map_insert</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>m</span> <span class=o>=</span> <span class=p>{{</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;one&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;two&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;three&#34;</span><span class=p>}};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>({</span><span class=mi>4</span><span class=p>,</span> <span class=s>&#34;four&#34;</span><span class=p>});</span>  <span class=c1>// ✅ 所有迭代器仍有效
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>m</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;five&#34;</span><span class=p>;</span>          <span class=c1>// ✅ 所有迭代器仍有效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>失效规则</strong>：</p><ul><li>插入操作<strong>不会</strong>导致任何迭代器失效</li></ul><hr><h3 id=52-删除操作>5.2 删除操作<a hidden class=anchor aria-hidden=true href=#52-删除操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>example_map_erase</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>m</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;one&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;two&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;three&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=s>&#34;four&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it1</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>           <span class=c1>// 指向{1, &#34;one&#34;}
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=n>it2</span> <span class=o>=</span> <span class=o>++</span><span class=n>m</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>         <span class=c1>// 指向{2, &#34;two&#34;}
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=n>it3</span> <span class=o>=</span> <span class=o>++</span><span class=p>(</span><span class=o>++</span><span class=n>m</span><span class=p>.</span><span class=n>begin</span><span class=p>());</span>     <span class=c1>// 指向{3, &#34;three&#34;}
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it2</span><span class=p>);</span>  <span class=c1>// ❌ 只有it2失效，it1和it3仍有效
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>it1</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// ✅ 输出: 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>it3</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// ✅ 输出: 3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// std::cout &lt;&lt; it2-&gt;first &lt;&lt; std::endl;  // ❌ 未定义行为
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>失效规则</strong>：</p><ul><li>删除操作<strong>只会</strong>使被删除元素的迭代器失效</li><li>其他迭代器不受影响</li></ul><p><strong>正确的删除循环</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>correct_map_erase</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>m</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;one&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;two&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;three&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=s>&#34;four&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// C++11以后，erase返回下一个有效迭代器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>m</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>it</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>it</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>  <span class=c1>// ✅ C++11
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// C++11之前的写法
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>m</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>it</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>m</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=o>++</span><span class=p>);</span>  <span class=c1>// ✅ 先拷贝it，再递增，然后删除拷贝的it
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=6-unordered_mapunordered_set的迭代器失效>6. unordered_map/unordered_set的迭代器失效<a hidden class=anchor aria-hidden=true href=#6-unordered_mapunordered_set的迭代器失效>#</a></h2><p><code>unordered_map</code>、<code>unordered_set</code>底层是<strong>哈希表</strong>。</p><h3 id=61-插入操作>6.1 插入操作<a hidden class=anchor aria-hidden=true href=#61-插入操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unordered_map&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>example_unordered_map_insert</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>um</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;one&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;two&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;three&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>um</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 如果插入导致rehash（负载因子超过阈值）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>um</span><span class=p>.</span><span class=n>insert</span><span class=p>({</span><span class=mi>4</span><span class=p>,</span> <span class=s>&#34;four&#34;</span><span class=p>});</span>  <span class=c1>// ⚠️ 可能触发rehash，所有迭代器失效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>失效规则</strong>：</p><ul><li>如果插入<strong>导致rehash</strong>：所有迭代器失效（但引用和指针仍有效）</li><li>如果<strong>没有rehash</strong>：所有迭代器仍有效</li></ul><p><strong>检查是否会rehash</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>check_rehash</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>um</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>um</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>  <span class=c1>// 预留空间，避免频繁rehash
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;bucket_count: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>um</span><span class=p>.</span><span class=n>bucket_count</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;load_factor: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>um</span><span class=p>.</span><span class=n>load_factor</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max_load_factor: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>um</span><span class=p>.</span><span class=n>max_load_factor</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 插入前检查
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>um</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&gt;</span> <span class=n>um</span><span class=p>.</span><span class=n>bucket_count</span><span class=p>()</span> <span class=o>*</span> <span class=n>um</span><span class=p>.</span><span class=n>max_load_factor</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;下次插入将触发rehash！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h3 id=62-删除操作>6.2 删除操作<a hidden class=anchor aria-hidden=true href=#62-删除操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>example_unordered_map_erase</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>um</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;one&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;two&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;three&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it1</span> <span class=o>=</span> <span class=n>um</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it2</span> <span class=o>=</span> <span class=o>++</span><span class=n>um</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>um</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it1</span><span class=p>);</span>  <span class=c1>// ❌ 只有it1失效，it2仍有效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>失效规则</strong>：</p><ul><li>删除操作<strong>只会</strong>使被删除元素的迭代器失效</li><li>其他迭代器不受影响</li></ul><hr><h2 id=7-迭代器失效的预防措施>7. 迭代器失效的预防措施<a hidden class=anchor aria-hidden=true href=#7-迭代器失效的预防措施>#</a></h2><h3 id=71-使用返回的迭代器>7.1 使用返回的迭代器<a hidden class=anchor aria-hidden=true href=#71-使用返回的迭代器>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// ✅ 始终使用insert/erase返回的迭代器
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>it</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>it</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>
</span></span></code></pre></div><hr><h3 id=72-预分配空间>7.2 预分配空间<a hidden class=anchor aria-hidden=true href=#72-预分配空间>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// ✅ 避免频繁扩容
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>vec</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>  <span class=c1>// 预留空间
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>um</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>um</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>  <span class=c1>// 预留空间，避免rehash
</span></span></span></code></pre></div><hr><h3 id=73-使用索引代替迭代器>7.3 使用索引代替迭代器<a hidden class=anchor aria-hidden=true href=#73-使用索引代替迭代器>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// ✅ 在vector中，索引不会失效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>vec</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>vec</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>vec</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 不需要i++，因为后面的元素会前移
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h3 id=74-使用remove-erase惯用法>7.4 使用remove-erase惯用法<a hidden class=anchor aria-hidden=true href=#74-使用remove-erase惯用法>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// ✅ 对于vector，使用remove-erase惯用法更安全
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>vec</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>remove_if</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> 
</span></span><span class=line><span class=cl>        <span class=p>[](</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}),</span>
</span></span><span class=line><span class=cl>    <span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><hr><h3 id=75-选择合适的容器>7.5 选择合适的容器<a hidden class=anchor aria-hidden=true href=#75-选择合适的容器>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 如果需要频繁插入删除，考虑使用list
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>lst</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// list的迭代器更稳定
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 如果需要稳定的迭代器且查找性能重要，考虑map/set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 插入不会导致迭代器失效
</span></span></span></code></pre></div><hr><h2 id=8-总结表格>8. 总结表格<a hidden class=anchor aria-hidden=true href=#8-总结表格>#</a></h2><table><thead><tr><th>容器类型</th><th>插入操作</th><th>删除操作</th></tr></thead><tbody><tr><td><strong>vector</strong></td><td>扩容时全部失效<br>不扩容时插入点及之后失效</td><td>删除点及之后失效</td></tr><tr><td><strong>deque</strong></td><td>首尾插入：所有迭代器失效<br>中间插入：全部失效</td><td>首尾删除：仅被删除元素失效<br>中间删除：全部失效</td></tr><tr><td><strong>list</strong></td><td>不会失效</td><td>仅被删除元素失效</td></tr><tr><td><strong>map/set</strong></td><td>不会失效</td><td>仅被删除元素失效</td></tr><tr><td><strong>unordered_map<br>unordered_set</strong></td><td>rehash时全部失效<br>否则不失效</td><td>仅被删除元素失效</td></tr></tbody></table><hr><h2 id=关键要点>关键要点<a hidden class=anchor aria-hidden=true href=#关键要点>#</a></h2><ol><li><strong>vector</strong>和<strong>deque</strong>最容易出现迭代器失效</li><li><strong>list</strong>、<strong>map/set</strong>的迭代器相对稳定</li><li><strong>unordered容器</strong>需要注意rehash</li><li>删除和插入操作后，始终使用返回的迭代器</li><li>尽量使用STL算法（如<code>remove_if</code>）而不是手动循环删除</li><li>预分配空间可以避免很多问题</li></ol><hr><h2 id=调试技巧>调试技巧<a hidden class=anchor aria-hidden=true href=#调试技巧>#</a></h2><ol><li><strong>编译器选项</strong>：使用<code>-D_GLIBCXX_DEBUG</code>（GCC）或类似选项开启调试模式</li><li><strong>AddressSanitizer</strong>：使用<code>-fsanitize=address</code>检测内存错误</li><li><strong>静态分析工具</strong>：使用clang-tidy等工具</li><li><strong>单元测试</strong>：为容器操作编写单元测试</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 编译时开启调试选项</span>
</span></span><span class=line><span class=cl>g++ -std<span class=o>=</span>c++17 -D_GLIBCXX_DEBUG -fsanitize<span class=o>=</span>address -g main.cpp -o main
</span></span></code></pre></div><hr><p><strong>参考资料</strong>：</p><ul><li>C++ Reference: <a href=https://en.cppreference.com/>https://en.cppreference.com/</a></li><li>Effective STL by Scott Meyers</li><li>C++ Primer 5th Edition</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://neo-dai.github.io/tags/c++/>C++</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://neo-dai.github.io/>Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default",securityLevel:"loose"}),document.querySelectorAll(".mermaid").length>0&&mermaid.run()</script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>