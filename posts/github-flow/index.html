<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>理解 GitHub Flow：我的极简 Git 工作流学习笔记 | myblog</title><meta name=keywords content="Git,GitHub,DevOps,工作流,编程"><meta name=description content="从混乱到清晰，这是我学到的 GitHub Flow 核心思想：一个主干、N个临时分支和N个版本快照。"><meta name=author content="neo"><link rel=canonical href=https://neo-dai.github.io/posts/github-flow/><link crossorigin=anonymous href=/assets/css/stylesheet.b4dfb58bc1aadc21cb0542f53df82233971252c1283b7ff385ac519b35b25bc3.css integrity="sha256-tN+1i8Gq3CHLBUL1PfgiM5cSUsEoO3/zhaxRmzWyW8M=" rel="preload stylesheet" as=style><link rel=icon href=https://neo-dai.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://neo-dai.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://neo-dai.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://neo-dai.github.io/apple-touch-icon.png><link rel=mask-icon href=https://neo-dai.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://neo-dai.github.io/posts/github-flow/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500;600;700&display=swap" rel=stylesheet><meta property="og:url" content="https://neo-dai.github.io/posts/github-flow/"><meta property="og:site_name" content="myblog"><meta property="og:title" content="理解 GitHub Flow：我的极简 Git 工作流学习笔记"><meta property="og:description" content="从混乱到清晰，这是我学到的 GitHub Flow 核心思想：一个主干、N个临时分支和N个版本快照。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-09T22:35:00+08:00"><meta property="article:modified_time" content="2025-11-09T22:35:00+08:00"><meta property="article:tag" content="Git"><meta property="article:tag" content="GitHub"><meta property="article:tag" content="DevOps"><meta property="article:tag" content="工作流"><meta property="article:tag" content="编程"><meta name=twitter:card content="summary"><meta name=twitter:title content="理解 GitHub Flow：我的极简 Git 工作流学习笔记"><meta name=twitter:description content="从混乱到清晰，这是我学到的 GitHub Flow 核心思想：一个主干、N个临时分支和N个版本快照。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://neo-dai.github.io/posts/"},{"@type":"ListItem","position":2,"name":"理解 GitHub Flow：我的极简 Git 工作流学习笔记","item":"https://neo-dai.github.io/posts/github-flow/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"理解 GitHub Flow：我的极简 Git 工作流学习笔记","name":"理解 GitHub Flow：我的极简 Git 工作流学习笔记","description":"从混乱到清晰，这是我学到的 GitHub Flow 核心思想：一个主干、N个临时分支和N个版本快照。","keywords":["Git","GitHub","DevOps","工作流","编程"],"articleBody":"为什么我需要一个新的 Git 工作流？ 在开始我的 MMO 服务器开发计划 时，我很快就遇到了一个问题：我该如何管理我的20个开发 “Lab”？\n我最初的想法是：“为每个 Lab 创建一个分支，最后再合并到 main？”\n事实证明，这个想法是完全错误的。它混淆了“过程”与“版本”。\n经过一番探索，我发现了一个更简单、更强大、也是目前最主流的模式：GitHub Flow。这篇笔记就是为了记录我对这个工作流的理解。\n什么是 GitHub Flow？ GitHub Flow 是一种轻量级的、基于分支的协作模式。它的哲学可以用两句话总结：\nmain 分支永远是神圣的。它必须在任何时刻都保持稳定、可部署。 所有的工作（新功能、Bug修复）都在临时的特性分支上进行，并通过 Pull Request (PR) 合并回 main。 没有复杂的 develop 分支，也没有冗长的 release 分支。它只有一个永恒的主干 (main) 和 N 个用完即焚的临时分支。\n核心开发循环：我的实践 下面，我用我的 lab1-chatroom (聊天室) 和 lab2-movement (移动同步) 作为例子，来走一遍完整的流程。\n步骤 1: 创建特性分支 永远不要、永远不要直接在 main 分支上写代码。\n当我要开始做“Lab 1 聊天室”时，我首先要基于最新的 main 分支，切出一个新分支：\n# 1. 确保我在 main 分支 git checkout main # 2. 拉取最新代码，确保我的 main 和远程 GitHub 上的 main 一致 git pull origin main # 3. 为我的新功能创建一个描述性的分支 git checkout -b feat/lab1-chatroom 命名规范： 我喜欢用 feat/ (功能) 或 fix/ (修复) 作为前缀，这样分支列表会非常清晰。 步骤 2: 本地开发与提交 现在，我在 feat/lab1-chatroom 这个“临时工作台”上，可以尽情地编写、调试、提交。\n# ... (编写聊天室 V0.1 的代码) ... # 提交我的工作 git add . git commit -m \"Feat: 实现 v0.1 基础回音服务器\" # ... (继续编写 v0.2, v0.3...) ... git add . git commit -m \"Feat: 实现 v0.3 广播与昵称功能\" 步骤 3: 发起拉取请求 (Pull Request - PR) 当我完成了 Lab 1 的所有功能，并且在本地测试通过后，我将这个分支推送到 GitHub：\ngit push origin feat/lab1-chatroom 然后，我打开 GitHub 仓库页面，点击 “Compare \u0026 pull request” 按钮。\nPR 是 GitHub Flow 的灵魂。 它不是一个简单的“合并”请求，它是一个沟通和评审的中心。在这里，我可以：\n@ 提醒我自己（或未来的同事）来审查代码。 写下这个功能解决了什么问题。 让 GitHub Actions 自动运行我的测试。 步骤 4: 评审、合并、删除 在（自己）确认 PR 里的代码没问题后，我按下了绿色的 “Merge pull request” 按钮。\n重点来了： 一旦合并，feat/lab1-chatroom 分支的使命就彻底终结了。\nmain 分支现在包含了 Lab 1 的所有代码。 GitHub 会提示我删除这个远程分支，我应该立即点击 “Delete branch”。 我还需要在本地清理这个本地分支： # 1. 切回 main git checkout main # 2. 拉取刚刚合并的最新代码 git pull origin main # 3. 删除已经没用的本地分支（-d 会安全检查，确保已合并） git branch -d feat/lab1-chatroom 步骤 5: 如此循环 当我开始做 Lab 2 时，我只需要重复步骤 1：\ngit checkout main git pull origin main git checkout -b feat/lab2-movement 我的 main 分支就像一个不断成长的树干，通过一次次 PR，不断吸收新的功能，永远保持健壮。\n进阶场景：开发 Lab 2 时发现 Lab 1 有 Bug 怎么办？ 这是我当时最困惑的问题，而 GitHub Flow 给了我一个极其优雅的答案。\n假设我正在 feat/lab2-movement 分支上写代码（可能写了一半，还没 commit），突然发现 Lab 1 的聊天室有 Bug。\n黄金法则： 永远不要在 lab2 的分支上修复 lab1 的 Bug！PR 必须保持纯净。\n正确的流程（中断 -\u003e 修复 -\u003e 恢复）：\n“暂停” Lab 2 的工作：\n# (在 feat/lab2-movement 分支上) # 将我所有写了一半的、未提交的改动“藏”起来 git stash “切换” 到 main 并创建修复分支：\ngit checkout main git pull origin main git checkout -b fix/lab1-chat-bug “修复” Bug 并合并：\n在 fix/lab1-chat-bug 上修复 Bug。 git commit -m \"Fix: 修复聊天消息重复的Bug\" git push origin fix/lab1-chat-bug 去 GitHub 提 PR -\u003e 立即 Merge -\u003e 删除 fix/ 分支。 现在，main 分支是健康的了。 “返回” Lab 2 并 “恢复” 工作：\n# 1. 切换回我的 Lab 2 分支 git checkout feat/lab2-movement # 2. [关键] 把 main 上的最新修复同步到我当前分支 git pull origin main # 3. [关键] 把我之前“藏”起来的工作“取”回来 git stash pop 完成！ 我现在又回到了 lab2 的开发中，代码没丢，而且 lab1 的 Bug 也被同步过来了。我可以继续安心开发 Lab 2。\n纠正我最大的误解：分支 (Branch) vs 标签 (Tag) 我终于搞懂了！\n分支 (Branch) 是一个临时的、可变的“工作台”。它用来承载未来的开发。\n标签 (Tag) 是一个永久的、不可变的“版本快照”。它用来标记过去的某个特定时刻。\n当我的 Lab 1 合并到 main 之后，我应该在 main 上打一个 Tag 来标记这个“版本”。\n# 确保在 main 上，并且是刚合并 Lab 1 的最新代码 git checkout main git pull origin main # 打一个 v0.1 的标签 git tag v0.1-lab1-chatroom # 把这个标签推送到 GitHub git push origin v0.1-lab1-chatroom 当我后来修复了 lab1 的 Bug 并合并回 main 后，v0.1 这个标签依然指向那个有 Bug 的旧 Commit。它是一张历史照片，无法被修改。\n我应该做的是，在修复 Bug 后的新 Commit 上，打一个新标签：\ngit tag v0.1.1-lab1-hotfix git push origin v0.1.1-lab1-hotfix 这就是为什么软件版本号是 1.0.1, 1.0.2…\n我的结论 GitHub Flow 真的非常简洁。它帮我厘清了混乱的思路。\nmain 是唯一的真相。 Branch 是临时的过程。 Pull Request 是沟通的桥梁。 Tag 是永恒的里程碑。 对于我的 MMO 项目，乃至未来所有的个人项目，这都将是我的标准工作流。\n","wordCount":"462","inLanguage":"en","datePublished":"2025-11-09T22:35:00+08:00","dateModified":"2025-11-09T22:35:00+08:00","author":{"@type":"Person","name":"neo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://neo-dai.github.io/posts/github-flow/"},"publisher":{"@type":"Organization","name":"myblog","logo":{"@type":"ImageObject","url":"https://neo-dai.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://neo-dai.github.io/ accesskey=h title="myblog (Alt + H)">myblog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://neo-dai.github.io/ title=首页><span>首页</span></a></li><li><a href=https://neo-dai.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://neo-dai.github.io/series/ title=专栏><span>专栏</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">理解 GitHub Flow：我的极简 Git 工作流学习笔记</h1><div class=post-description>从混乱到清晰，这是我学到的 GitHub Flow 核心思想：一个主干、N个临时分支和N个版本快照。</div><div class=post-meta><span title='2025-11-09 22:35:00 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>neo</span></div></header><div class=post-content><h2 id=为什么我需要一个新的-git-工作流>为什么我需要一个新的 Git 工作流？<a hidden class=anchor aria-hidden=true href=#为什么我需要一个新的-git-工作流>#</a></h2><p>在开始我的 <a href=/posts/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E6%97%85/>MMO 服务器开发计划</a> 时，我很快就遇到了一个问题：我该如何管理我的20个开发 &ldquo;Lab&rdquo;？</p><p>我最初的想法是：“为每个 Lab 创建一个分支，最后再合并到 <code>main</code>？”</p><p>事实证明，这个想法是完全错误的。它混淆了“过程”与“版本”。</p><p>经过一番探索，我发现了一个更简单、更强大、也是目前最主流的模式：<strong>GitHub Flow</strong>。这篇笔记就是为了记录我对这个工作流的理解。</p><h2 id=什么是-github-flow>什么是 GitHub Flow？<a hidden class=anchor aria-hidden=true href=#什么是-github-flow>#</a></h2><p>GitHub Flow 是一种轻量级的、基于分支的协作模式。它的哲学可以用两句话总结：</p><ol><li><code>main</code> 分支永远是<strong>神圣的</strong>。它必须<strong>在任何时刻都保持稳定、可部署</strong>。</li><li><strong>所有的工作</strong>（新功能、Bug修复）都在<strong>临时的特性分支</strong>上进行，并通过 <strong>Pull Request (PR)</strong> 合并回 <code>main</code>。</li></ol><p>没有复杂的 <code>develop</code> 分支，也没有冗长的 <code>release</code> 分支。它只有一个<strong>永恒的主干 (<code>main</code>)</strong> 和 <strong>N 个用完即焚的临时分支</strong>。</p><hr><h2 id=核心开发循环我的实践>核心开发循环：我的实践<a hidden class=anchor aria-hidden=true href=#核心开发循环我的实践>#</a></h2><p>下面，我用我的 <code>lab1-chatroom</code> (聊天室) 和 <code>lab2-movement</code> (移动同步) 作为例子，来走一遍完整的流程。</p><h3 id=步骤-1-创建特性分支>步骤 1: 创建特性分支<a hidden class=anchor aria-hidden=true href=#步骤-1-创建特性分支>#</a></h3><p>永远不要、永远不要直接在 <code>main</code> 分支上写代码。</p><p>当我要开始做“Lab 1 聊天室”时，我首先要基于最新的 <code>main</code> 分支，切出一个新分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 1. 确保我在 main 分支</span>
</span></span><span class=line><span class=cl>git checkout main
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. 拉取最新代码，确保我的 main 和远程 GitHub 上的 main 一致</span>
</span></span><span class=line><span class=cl>git pull origin main
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. 为我的新功能创建一个描述性的分支</span>
</span></span><span class=line><span class=cl>git checkout -b feat/lab1-chatroom
</span></span></code></pre></div><ul><li><strong>命名规范：</strong> 我喜欢用 <code>feat/</code> (功能) 或 <code>fix/</code> (修复) 作为前缀，这样分支列表会非常清晰。</li></ul><h3 id=步骤-2-本地开发与提交>步骤 2: 本地开发与提交<a hidden class=anchor aria-hidden=true href=#步骤-2-本地开发与提交>#</a></h3><p>现在，我在 <code>feat/lab1-chatroom</code> 这个“临时工作台”上，可以尽情地编写、调试、提交。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># ... (编写聊天室 V0.1 的代码) ...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 提交我的工作</span>
</span></span><span class=line><span class=cl>git add .
</span></span><span class=line><span class=cl>git commit -m <span class=s2>&#34;Feat: 实现 v0.1 基础回音服务器&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ... (继续编写 v0.2, v0.3...) ...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git add .
</span></span><span class=line><span class=cl>git commit -m <span class=s2>&#34;Feat: 实现 v0.3 广播与昵称功能&#34;</span>
</span></span></code></pre></div><h3 id=步骤-3-发起拉取请求-pull-request---pr>步骤 3: 发起拉取请求 (Pull Request - PR)<a hidden class=anchor aria-hidden=true href=#步骤-3-发起拉取请求-pull-request---pr>#</a></h3><p>当我完成了 Lab 1 的所有功能，并且在本地测试通过后，我将这个分支推送到 GitHub：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git push origin feat/lab1-chatroom
</span></span></code></pre></div><p>然后，我打开 GitHub 仓库页面，点击 &ldquo;Compare & pull request&rdquo; 按钮。</p><p><strong>PR 是 GitHub Flow 的灵魂。</strong> 它不是一个简单的“合并”请求，它是一个<strong>沟通和评审</strong>的中心。在这里，我可以：</p><ul><li>@ 提醒我自己（或未来的同事）来审查代码。</li><li>写下这个功能解决了什么问题。</li><li>让 GitHub Actions 自动运行我的测试。</li></ul><h3 id=步骤-4-评审合并删除>步骤 4: 评审、合并、删除<a hidden class=anchor aria-hidden=true href=#步骤-4-评审合并删除>#</a></h3><p>在（自己）确认 PR 里的代码没问题后，我按下了绿色的 &ldquo;Merge pull request&rdquo; 按钮。</p><p><strong>重点来了：</strong> 一旦合并，<code>feat/lab1-chatroom</code> 分支的使命就<strong>彻底终结</strong>了。</p><ol><li><code>main</code> 分支现在包含了 Lab 1 的所有代码。</li><li>GitHub 会提示我删除这个<strong>远程分支</strong>，我应该立即点击 &ldquo;Delete branch&rdquo;。</li><li>我还需要在本地清理这个<strong>本地分支</strong>：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 1. 切回 main</span>
</span></span><span class=line><span class=cl>git checkout main
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. 拉取刚刚合并的最新代码</span>
</span></span><span class=line><span class=cl>git pull origin main
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. 删除已经没用的本地分支（-d 会安全检查，确保已合并）</span>
</span></span><span class=line><span class=cl>git branch -d feat/lab1-chatroom
</span></span></code></pre></div><h3 id=步骤-5-如此循环>步骤 5: 如此循环<a hidden class=anchor aria-hidden=true href=#步骤-5-如此循环>#</a></h3><p>当我开始做 Lab 2 时，我只需要重复<strong>步骤 1</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git checkout main
</span></span><span class=line><span class=cl>git pull origin main
</span></span><span class=line><span class=cl>git checkout -b feat/lab2-movement
</span></span></code></pre></div><p>我的 <code>main</code> 分支就像一个不断成长的树干，通过一次次 PR，不断吸收新的功能，永远保持健壮。</p><hr><h2 id=进阶场景开发-lab-2-时发现-lab-1-有-bug-怎么办>进阶场景：开发 Lab 2 时发现 Lab 1 有 Bug 怎么办？<a hidden class=anchor aria-hidden=true href=#进阶场景开发-lab-2-时发现-lab-1-有-bug-怎么办>#</a></h2><p>这是我当时最困惑的问题，而 GitHub Flow 给了我一个极其优雅的答案。</p><p>假设我正在 <code>feat/lab2-movement</code> 分支上写代码（可能写了一半，还没 <code>commit</code>），突然发现 Lab 1 的聊天室有 Bug。</p><p><strong>黄金法则：</strong> 永远不要在 <code>lab2</code> 的分支上修复 <code>lab1</code> 的 Bug！PR 必须保持纯净。</p><p>正确的流程（中断 -> 修复 -> 恢复）：</p><ol><li><p><strong>&ldquo;暂停&rdquo; Lab 2 的工作：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># (在 feat/lab2-movement 分支上)</span>
</span></span><span class=line><span class=cl><span class=c1># 将我所有写了一半的、未提交的改动“藏”起来</span>
</span></span><span class=line><span class=cl>git stash
</span></span></code></pre></div></li><li><p><strong>&ldquo;切换&rdquo; 到 <code>main</code> 并创建修复分支：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git checkout main
</span></span><span class=line><span class=cl>git pull origin main
</span></span><span class=line><span class=cl>git checkout -b fix/lab1-chat-bug
</span></span></code></pre></div></li><li><p><strong>&ldquo;修复&rdquo; Bug 并合并：</strong></p><ul><li>在 <code>fix/lab1-chat-bug</code> 上修复 Bug。</li><li><code>git commit -m "Fix: 修复聊天消息重复的Bug"</code></li><li><code>git push origin fix/lab1-chat-bug</code></li><li>去 GitHub 提 PR -> 立即 Merge -> 删除 <code>fix/</code> 分支。</li><li><strong>现在，<code>main</code> 分支是健康的了。</strong></li></ul></li><li><p><strong>&ldquo;返回&rdquo; Lab 2 并 &ldquo;恢复&rdquo; 工作：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 1. 切换回我的 Lab 2 分支</span>
</span></span><span class=line><span class=cl>git checkout feat/lab2-movement
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. [关键] 把 main 上的最新修复同步到我当前分支</span>
</span></span><span class=line><span class=cl>git pull origin main
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. [关键] 把我之前“藏”起来的工作“取”回来</span>
</span></span><span class=line><span class=cl>git stash pop
</span></span></code></pre></div></li><li><p><strong>完成！</strong> 我现在又回到了 <code>lab2</code> 的开发中，代码没丢，而且 <code>lab1</code> 的 Bug 也被同步过来了。我可以继续安心开发 Lab 2。</p></li></ol><hr><h2 id=纠正我最大的误解分支-branch-vs-标签-tag>纠正我最大的误解：分支 (Branch) vs 标签 (Tag)<a hidden class=anchor aria-hidden=true href=#纠正我最大的误解分支-branch-vs-标签-tag>#</a></h2><p>我终于搞懂了！</p><blockquote><p><strong>分支 (Branch)</strong> 是一个<strong>临时的、可变的“工作台”</strong>。它用来承载<strong>未来</strong>的开发。</p><p><strong>标签 (Tag)</strong> 是一个<strong>永久的、不可变的“版本快照”</strong>。它用来标记<strong>过去</strong>的某个特定时刻。</p></blockquote><p>当我的 Lab 1 合并到 <code>main</code> 之后，我应该在 <code>main</code> 上打一个 <strong>Tag</strong> 来标记这个“版本”。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 确保在 main 上，并且是刚合并 Lab 1 的最新代码</span>
</span></span><span class=line><span class=cl>git checkout main
</span></span><span class=line><span class=cl>git pull origin main
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 打一个 v0.1 的标签</span>
</span></span><span class=line><span class=cl>git tag v0.1-lab1-chatroom
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 把这个标签推送到 GitHub</span>
</span></span><span class=line><span class=cl>git push origin v0.1-lab1-chatroom
</span></span></code></pre></div><p>当我后来修复了 <code>lab1</code> 的 Bug 并合并回 <code>main</code> 后，<code>v0.1</code> 这个标签<strong>依然指向那个有 Bug 的旧 Commit</strong>。它是一张<strong>历史照片</strong>，无法被修改。</p><p>我应该做的是，在修复 Bug 后的新 Commit 上，打一个<strong>新标签</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git tag v0.1.1-lab1-hotfix
</span></span><span class=line><span class=cl>git push origin v0.1.1-lab1-hotfix
</span></span></code></pre></div><p>这就是为什么软件版本号是 <code>1.0.1</code>, <code>1.0.2</code>&mldr;</p><h2 id=我的结论>我的结论<a hidden class=anchor aria-hidden=true href=#我的结论>#</a></h2><p>GitHub Flow 真的非常简洁。它帮我厘清了混乱的思路。</p><ul><li><strong><code>main</code> 是唯一的真相。</strong></li><li><strong><code>Branch</code> 是临时的过程。</strong></li><li><strong><code>Pull Request</code> 是沟通的桥梁。</strong></li><li><strong><code>Tag</code> 是永恒的里程碑。</strong></li></ul><p>对于我的 MMO 项目，乃至未来所有的个人项目，这都将是我的标准工作流。</p><pre tabindex=0><code></code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://neo-dai.github.io/tags/git/>Git</a></li><li><a href=https://neo-dai.github.io/tags/github/>GitHub</a></li><li><a href=https://neo-dai.github.io/tags/devops/>DevOps</a></li><li><a href=https://neo-dai.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/>工作流</a></li><li><a href=https://neo-dai.github.io/tags/%E7%BC%96%E7%A8%8B/>编程</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://neo-dai.github.io/>myblog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default",securityLevel:"loose"}),document.querySelectorAll(".mermaid").length>0&&mermaid.run()</script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>