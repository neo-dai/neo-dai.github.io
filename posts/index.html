<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Notes</title><meta name=keywords content><meta name=description content="Posts - Notes"><meta name=author content="neo"><link rel=canonical href=https://neo-dai.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.b4dfb58bc1aadc21cb0542f53df82233971252c1283b7ff385ac519b35b25bc3.css integrity="sha256-tN+1i8Gq3CHLBUL1PfgiM5cSUsEoO3/zhaxRmzWyW8M=" rel="preload stylesheet" as=style><link rel=icon href=https://neo-dai.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://neo-dai.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://neo-dai.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://neo-dai.github.io/apple-touch-icon.png><link rel=mask-icon href=https://neo-dai.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://neo-dai.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://neo-dai.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500;600;700&display=swap" rel=stylesheet><meta property="og:url" content="https://neo-dai.github.io/posts/"><meta property="og:site_name" content="Notes"><meta property="og:title" content="Posts"><meta property="og:description" content="CodeLabs"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="CodeLabs"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://neo-dai.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://neo-dai.github.io/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://neo-dai.github.io/ title=首页><span>首页</span></a></li><li><a href=https://neo-dai.github.io/posts/ title=文章><span class=active>文章</span></a></li><li><a href=https://neo-dai.github.io/series/ title=专栏><span>专栏</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LeetCode49 字母异位词分组</h2></header><div class=entry-content><p>一、题目描述 leetcode链接
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
字母异位词 : 字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。
示例 1:
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: “[["bat"],["nat","tan"],["ate","eat","tea"]]”
解释：
在 strs 中没有字符串可以通过重新排列来形成 "bat"。 字符串 "nat" 和 "tan" 是字母异位词，因为它们可以重新排列以形成彼此。 字符串 "ate" ，"eat" 和 "tea" 是字母异位词，因为它们可以重新排列以形成彼此。 示例 2:
输入: strs = [""]
输出: [[""]]
示例 3:
输入: strs = ["a"]
输出: [[“a”]]
提示：
1 &lt;= strs.length &lt;= 104 0 &lt;= strs[i].length &lt;= 100 strs[i] 仅包含小写字母 二、解题思路 核心思想 同类型的字符串仅仅字母顺序不同，意味着将其排序后就可以作为hash表索引，实现快速找到自己的分组 算法步骤 构建索引：遍历一遍strs将字符串排序后拿到索引，并使用索引找到hash表中分组的位置实现插入 构建结果：将hash表以题目要求的方式返回 优化 既然是以字符串为索引 且小写字母只有26个， 那就可以使用字母出现的次数作为索引，这样就不用给每个字符串排序了，在单个字符串非常长的情况下效果显著 三、 复杂度分析 排序法 时间复杂度: $O(n*klogk)$， n是数组长度 k是字符串长度 空间复杂度: $O(n*k)$，存储 n 个字符串作为 value，最多 n 个 key（每个 key 长度为 k） 计数法 时间复杂度：$O(n*k)$ 空间复杂度： $O(n*k)$ 四、代码实现 C++实现 （耗时：1h20min） class Solution { public: // 计数法 vector&lt;vector&lt;string>> groupAnagrams(vector&lt;string>& strs) { // 1. 构建索引 unordered_map&lt;string,vector&lt;string>> tmp; for (const auto& str : strs) { string key(26,'0'); for (const char& c : str ) { key[c-'a']++; } tmp[key].push_back(str); } // 2. 构建结果 vector&lt;vector&lt;string>> result; result.reserve(tmp.size()); for (auto& it : tmp) { result.push_back(std::move(it.second)); } // 3. 返回结果 return result; } // 排序法 vector&lt;vector&lt;string>> groupAnagrams2(vector&lt;string>& strs) { // 1. 构建索引 unordered_map&lt;string,vector&lt;string>> tmp; for (const auto& str : strs) { string key = str; sort(key.begin(),key.end()); tmp[key].push_back(str); } // 2. 构建结果 vector&lt;vector&lt;string>> result; result.reserve(tmp.size()); for (auto& it : tmp) { // tips： 使用 std::move 来避免大量字符串 vector 的深拷贝 result.push_back(std::move(it.second)); } // 3. 返回结果 return result; } }; go 实现 // 排序法 func groupAnagrams(strs []string) [][]string { // 1. 构建索引（排序法） // 由于 sort 无法直接排序 string，需要转换为 []byte mp := make(map[string][]string) for _, str := range strs { b := []byte(str) sort.Slice(b, func(i, j int) bool { return b[i] &lt; b[j] }) key := string(b) mp[key] = append(mp[key], str) } // 2. 构建结果 result := make([][]string, 0, len(mp)) for _, v := range mp { result = append(result, v) } return result } // 计数法 func groupAnagrams2(strs []string) [][]string { // 1. 构建索引 mp := make(map[[26]int][]string) for _, str := range strs { // tips: 需要注意的是str仅仅为值拷贝，并非引用 如果需要修改数组元素需要访问strs[i] var count [26]int for _, c := range str { count[c-'a']++ } mp[count] = append(mp[count], str) } // 2. 构建结果 // tips: 使用make提前预分配容量可以显著减少内存分配和数据复制 result := make([][]string, 0, len(mp)) for _, v := range mp { result = append(result, v) } return result } 五、 总结 核心逻辑：映射（Mapping）
...</p></div><footer class=entry-footer><span title='2025-12-10 17:51:34 +0800 +0800'>2025年12月10日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to LeetCode49 字母异位词分组" href=https://neo-dai.github.io/posts/leetcode49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AI使用技巧（开篇）</h2></header><div class=entry-content><p>前言 用了很久 AI，起初我只是把它当作一个更聪明的搜索引擎，或者偶尔用来生成点代码片段的工具。但随着接触的 AI 应用越来越多，我发现它带来的改变远超预期：
在代码侧：开发模式从传统“设计-开发-自测”的执行者，进化为一名 Tech Lead，指挥着多个 AI Agent 协作流转、Agent之间通过文件实现交流： Agent 1 负责和我把需求与设计聊透并将具体实施方案的Prompt写入文件(ClaudeOpus4.5 Think)； Agent 2 读取方案后负责以“小步迭代”的形式分步实现，并确保单元测试覆盖(ClaudeSonnet4.5)； Agent 3 负责构建、测试与反馈(ClaudeSonnet3.5)。 在学习侧：AI 成了最好的私人导师。它拥有海量知识库的同时又充满耐心，能帮我快速啃下分布式系统、源码分析等硬骨头。 在生活侧：它甚至像一面镜子。当我把日记交给 Cursor 管理时，它总能精准地指出我思维中的盲区和潜在问题，并给出非常可行的改进建议；或者没事就和豆包打电话聊天，它是生活中的百事通。 因此，系统性地学习如何更好地使用 AI 是一件极具价值的事情。于是我准备开启这个 Blog 系列——这既是 AI 的建议，也是费曼学习法的一次实践，通过输出倒逼输入，完成知识的内化。
施工计划 (Roadmap) AI 使用技巧(一)：如何高效与AI对话
提示词技巧 AI时代的《提问的智慧》 AI 使用技巧(二)： Cursor使用技巧
AI 使用技巧(三)： ClaudeCode使用技巧
AI 使用技巧(四): Vibe Coding技巧
多Agent合作，高效的同时最大化节省Token 如何避免AI”偷懒“ 如何快速熟悉新项目或应对复杂历史遗留代码 复杂日志分析与debug AI 使用技巧(五): 如何利用AI快速掌握一个新的技能
使用AI导师辅助学习Golang 使用AI导师辅助学习MIT6.824(天坑难度) AI 使用技巧(六): 如何“训练”一个专属于自己的AI
项目知识库问答AI定制 Talk is cheap, I will show you the prompt. 持续更新中…</p></div><footer class=entry-footer><span title='2025-11-28 17:13:13 +0800 +0800'>2025年11月28日</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to AI使用技巧（开篇）" href=https://neo-dai.github.io/posts/ai%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BC%80%E7%AF%87/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>健身动作库</h2></header><div class=entry-content><p>杠铃卧推 目标肌群: 胸大肌（整体）、肱三头肌、三角肌前束 动作流程: 平躺于卧推凳，双脚踩实地面，肩胛骨后收下沉。 握距稍宽于肩，起杠后将杠铃悬停于肩部正上方。 吸气，控制速度下放杠铃至胸骨中部（乳头连线处），前臂垂直地面。 呼气，发力将杠铃推回起始位置。 核心点/易错点: 核心稳定: 保持腹部收紧，不要过度弓腰。 手腕中立: 避免手腕过度后折，以免压迫腕关节。 上斜哑铃卧推 目标肌群: 上胸肌、三角肌前束 动作流程: 调节椅背至30°-45°。 双手持哑铃举至肩上方，掌心朝前。 吸气慢放，感受上胸拉伸；呼气推起至手臂伸直（微屈）。 核心点/易错点: 角度选择: 角度过大（>60°）会变成推肩。 前臂垂直: 任何时候前臂都应垂直于地面。 双杠臂屈伸 目标肌群: 胸大肌下束（前倾）、肱三头肌（直立） 动作流程: 双手握杠，身体悬空。 屈肘下放身体，直至大臂平行地面。 撑起身体还原。 核心点/易错点: 保护肩部: 下放不要过深，以免拉伤肩关节。 目标区分: 身体前倾、手肘外展侧重练胸；身体直立、夹肘侧重练臂。 哑铃过头臂屈伸 目标肌群: 肱三头肌（长头） 动作流程: 坐姿或站姿，双手托住哑铃一端举过头顶。 大臂夹紧头部两侧，屈肘将哑铃下放至颈后。 伸直手臂还原。 核心点/易错点: 大臂固定: 全程大臂尽量不动，不要向外打开。 腰椎保护: 核心收紧，避免肋骨外翻和塌腰。 绳索臂屈伸 目标肌群: 肱三头肌（侧重外侧头、内侧头） 动作流程: 站立，双脚与肩同宽，身体微前倾。 大臂夹紧身体两侧固定。 呼气，伸直手臂向下压，直至手臂完全伸直。 吸气，缓慢还原至小臂平行地面。 核心点/易错点: 只动小臂: 避免大臂前后晃动借力。 顶峰收缩: 动作底部手腕外旋（若用绳索），挤压三头肌。 平板蝴蝶收腹 目标肌群: 腹直肌 动作流程: 平躺，脚掌相对（呈蝴蝶状），膝盖向外打开。 双手置于头后或胸前。 呼气卷起上背部，吸气还原。 核心点/易错点: 消除借力: 蝴蝶腿姿势可减少髂腰肌借力，更孤立腹肌。 不要抱头: 避免双手用力拉拽颈部。 卷腹 目标肌群: 腹直肌上部 动作流程: 平躺，屈膝，双脚踩地。 呼气，依靠腹肌收缩将肩胛骨拉离地面。 吸气，缓慢下放。 核心点/易错点: 幅度控制: 不需要坐起，只需卷起上背部。 颈部放松: 下巴微收，视线看向膝盖方向。 坐姿划船 目标肌群: 背阔肌、中下斜方肌、菱形肌 动作流程: 坐于器械上，脚踩踏板，膝盖微屈。 保持背部挺直，将把手拉向腹部。 感受背部肌群夹紧，缓慢还原。 核心点/易错点: 先肩后手: 启动时先做肩胛后缩，再屈肘拉动。 避免晃动: 躯干保持稳定，不要过度后仰借力。 杠铃划船 目标肌群: 背阔肌（厚度）、大圆肌、三角肌后束 动作流程: 俯身，背部挺直与地面呈45°或更低。 双手正手或反手握杠。 将杠铃沿大腿拉向腹部位置。 核心点/易错点: 腰背挺直: 严禁弓腰，防止腰椎受伤。 手肘贴身: 拉起时手肘尽量贴近身体。 窄距下拉 目标肌群: 背阔肌下部 动作流程: 坐于下拉器械，使用V柄或窄握。 挺胸，将把手拉至上胸部。 控制回放速度。 核心点/易错点: 挺胸沉肩: 全程保持挺胸，下拉时肩膀下沉。 挤压背部: 动作底部用力挤压背阔肌。 哑铃划船 目标肌群: 单侧背阔肌 动作流程: 单手单膝支撑于长凳，背部平直。 另一手持哑铃，自然下垂。 呼气，将哑铃拉向髋部方向。 核心点/易错点: 划弧线: 哑铃运动轨迹是向后上方的弧线，而不是直上直下。 躯干稳定: 避免身体随动作扭转。 哑铃弯举 目标肌群: 肱二头肌 动作流程: 站立或坐姿，掌心向前。 大臂固定，屈肘将哑铃举起。 顶峰收缩后缓慢下放。 核心点/易错点: 避免摇晃: 不要利用身体惯性甩起哑铃。 离心控制: 下放过程要慢，抗阻力。 锤式弯举 目标肌群: 肱肌、肱二头肌外侧、肱桡肌 动作流程: 掌心相对（对握）。 保持掌心相对姿势，屈肘举起哑铃。 核心点/易错点: 手腕锁定: 手腕保持中立，不要弯曲。 增加厚度: 此动作对增加手臂正面视觉宽度很有效。 集中弯举 目标肌群: 肱二头肌（肌峰） 动作流程: 坐姿，双腿分开，持铃手的大臂后侧抵住同侧大腿内侧。 孤立发力弯举哑铃。 核心点/易错点: 完全孤立: 借助大腿固定大臂，彻底消除借力。 顶峰挤压: 在最高点停顿1-2秒。 深蹲 目标肌群: 股四头肌、臀大肌、核心 动作流程: 杠铃置于斜方肌上，双脚略宽于肩。 屈髋屈膝下蹲，膝盖方向与脚尖一致。 蹲至大腿平行地面或更低，发力站起。 核心点/易错点: 膝盖指向: 严禁膝盖内扣。 背部挺直: 保持脊柱中立，不要通过弯腰来达到下蹲深度。 坐姿腿屈伸 目标肌群: 股四头肌（刻画线条） 动作流程: 调整器械，使膝关节对准转轴。 呼气，股四头肌发力将小腿踢直。 吸气缓慢还原。 核心点/易错点: 勾脚尖: 动作过程中保持勾脚尖可增加肌肉收缩感。 不要锁死: 膝盖伸直时保留微屈，保护关节。 腿举 目标肌群: 股四头肌、臀大肌（取决于脚位） 动作流程: 坐入器械，背部紧贴靠背。 双脚蹬板，解锁保险。 屈膝下放至大小腿呈90°，蹬起。 核心点/易错点: 臀部贴紧: 蹬起时臀部不要离开座垫。 膝盖微屈: 顶部不要完全锁死膝盖。 站姿杠铃推举 目标肌群: 三角肌前束、中束，核心 动作流程: 杠铃置于上胸，双手略宽于肩。 收紧臀腹，将杠铃垂直推举过头顶。 头部在杠铃过额头后略微前探。 核心点/易错点: 核心收紧: 避免过度后仰变成上斜卧推。 轨迹垂直: 杠铃运动轨迹应垂直于地面。 哑铃推肩 目标肌群: 三角肌前束、中束 动作流程: 坐姿，双手持铃举至双耳旁。 呼气推举至头顶，哑铃互不触碰。 吸气下放至大臂平行地面或略低。 核心点/易错点: 手肘朝前: 手肘略微朝前，不要完全向两侧打开（保护肩关节）。 行程完整: 下放要充分，不要只做半程。 侧平举 目标肌群: 三角肌中束（肩宽关键） 动作流程: 站立微前倾，双手持铃垂于身前。 肘部微屈，以肩为轴将哑铃向两侧举起。 举至大臂与地面平行即可。 核心点/易错点: 倒水姿势: 想象像倒水一样，小拇指略高于大拇指（内旋），但需注意肩峰撞击风险，新手可保持平举。 手肘引导: 是手肘带动小臂和哑铃，而不是手腕用力挑起。 俯身飞鸟 目标肌群: 三角肌后束 动作流程: 俯身至躯干接近平行地面。 像大鹏展翅一样将哑铃向两侧后方举起。 核心点/易错点: 不要夹背: 主要是肩后束发力，过度夹背会练到斜方肌。 控制惯性: 避免利用身体起伏甩动哑铃。 坐姿髋外展 目标肌群: 臀中肌、臀小肌 动作流程: 坐于器械，大腿外侧贴挡板。 用臀部力量将双腿向外打开。 核心点/易错点: 躯干位置: 身体前倾可更多刺激臀大肌上部，后靠更多刺激臀中肌。 坐姿髋内收 目标肌群: 大腿内收肌群 动作流程: 坐于器械，大腿内侧贴挡板。 用大腿内侧力量将双腿向内夹紧。 核心点/易错点: 控制回放: 离心阶段要控制速度，不要让配重片猛烈撞击。 哑铃卧推 目标肌群: 胸大肌（特别是中缝和整体厚度） 动作流程: 平躺，双手持铃，掌心朝前。 下放至胸部两侧，感受拉伸。 推起至顶点，哑铃靠拢但不触碰。 核心点/易错点: 活动范围: 相比杠铃，哑铃下放更深，拉伸感更强。 顶部挤压: 推起时想象二头肌去触碰胸肌。 上斜哑铃飞鸟 目标肌群: 上胸肌（中缝） 动作流程: 上斜凳，掌心相对。 手臂微屈固定，像抱大树一样向两侧打开。 胸肌发力将哑铃抱回上方。 核心点/易错点: 肘部角度: 全程保持肘部微屈固定，不要变伸缩手臂（变成卧推）。 拉伸感: 底部充分拉伸，但不要过度以免伤肩。 器械推胸 目标肌群: 胸大肌 动作流程: 调整座椅高度，使握把位于中胸高度。 挺胸，推起握把。 核心点/易错点: 安全稳定: 适合新手寻找胸肌发力感，且较安全。 肩部固定: 即使推到最远端，肩膀也要贴在椅背上，不要送肩。 哑铃臂屈伸 (仰卧) 目标肌群: 肱三头肌 动作流程: 平躺，双手持铃举起，掌心相对。 屈肘将哑铃下放至耳侧或额头上方。 伸直手臂还原。 核心点/易错点: 大臂角度: 大臂可微向后倾斜，保持三头肌持续张力。 肘部收紧: 避免肘部过度外张。 绳索弯举 目标肌群: 肱二头肌 动作流程: 龙门架低位滑轮，双手握杆。 站立弯举。 核心点/易错点: 持续张力: 绳索的特点是全程都有张力，顶峰收缩效果好。 上斜哑铃弯举 目标肌群: 肱二头肌（长头） 动作流程: 躺在上斜凳（45°-60°）上。 手臂自然下垂，进行弯举。 核心点/易错点: 拉伸长头: 利用身后位置充分拉伸二头肌长头。 肘部稳定: 肘部需始终指向地面，不要前移。 牧师凳锤式弯举 目标肌群: 肱肌、肱桡肌 动作流程: 腋下卡住牧师凳边缘。 竖握哑铃（锤式）进行弯举。 核心点/易错点: 无法借力: 此动作完全孤立，重量选轻一点。 哑铃箭步蹲 目标肌群: 股四头肌、臀大肌 动作流程: 双手持铃垂于体侧。 向前迈一大步下蹲，前后腿均呈90°。 前腿发力蹬回。 核心点/易错点: 重心控制: 躯干直立侧重股四，前倾侧重臀部。 膝盖保护: 前脚膝盖不要过度超过脚尖，后腿膝盖不触地。 硬拉 (传统) 目标肌群: 后链肌群（背部、臀部、腘绳肌） 动作流程: 杠铃贴小腿，双脚与髋同宽。 屈髋屈膝握杆，背部挺直收紧。 脚后跟蹬地，髋膝同时伸展将杠铃拉起。 核心点/易错点: 启动: 想象是用脚蹬离地面，而不是用手拉起杠铃。 脊柱中立: 全程严禁龟背（弓腰）。 哑铃直腿硬拉 (RDL) 目标肌群: 腘绳肌（大腿后侧）、臀大肌 动作流程: 微屈膝固定（并非完全直腿）。 屈髋（屁股向后撅），哑铃沿腿部前侧下放。 感受大腿后侧拉伸，臀部发力顶髋回正。 核心点/易错点: 屈髋主导: 动作是屁股前后动，不是上下蹲。 杠铃贴腿: 哑铃/杠铃始终贴着腿上下，减少腰部压力。 阿诺德推肩 目标肌群: 三角肌前、中束 动作流程: 起始位掌心朝向面部。 外展肩部的同时旋转手腕推起。 终点位掌心朝前。 核心点/易错点: 流畅旋转: 推举与旋转同步进行。 行程更长: 相比普通推肩刺激范围更广，但重量不宜过大。 半俯身侧平举 目标肌群: 三角肌侧后方 动作流程: 一手抓固定物，身体略微倾斜。 另一手持铃向侧上方举起。 核心点/易错点: 解决借力: 倾斜身体改变了阻力力矩，能更好刺激三角肌中束起始阶段。 蝴蝶机反向飞鸟 目标肌群: 三角肌后束 动作流程: 面向蝴蝶机坐，双手反向握把。 向后打开双臂，直至与背部成一直线。 核心点/易错点: 不要缩颈: 保持沉肩，避免斜方肌代偿。 手肘微屈: 手臂不要完全伸直锁死。</p></div><footer class=entry-footer><span title='2025-11-24 20:19:18 +0800 +0800'>2025年11月24日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 健身动作库" href=https://neo-dai.github.io/posts/%E5%81%A5%E8%BA%AB/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang基础语法</h2></header><div class=entry-content><p>本文将简要介绍 Go (Golang) 语言的基础语法和核心概念，适合有一定编程基础但刚接触 Go 的读者。通过具体示例，您可以快速了解 Go 的基本结构、数据类型、函数用法以及常用的编码习惯，有助于后续深入学习和项目实践。
package & import 每个程序都是由包构成，main本身也是一个package 可以通过import导入其他包来使用 package main import ( "fmt" "math/rand" ) func main() { fmt.Println("我最喜欢的数字是 ", rand.Intn(10)) fmt.Println("rand.Intn(20)") } 导出名（Exported） package 中 首字母大写的字段可以给其他包直接访问，反之则不行 package infrastructure // Datacenter 结构体是导出的 (public) type Datacenter struct { // serverCount 首字母小写，是未导出的 (private) // 只有 infrastructure 包内部的代码能访问它 serverCount int } // AddServer 首字母大写，是导出的 (public) func (d *Datacenter) AddServer() { d.serverCount++ } 函数 基础函数 func add(x int, y int) int { return x + y } 简写1 func add(x , y int) int { return x + y } 多返回值 func swap(x, y string) (string, string) { return y, x } 带名字的返回值 func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } 结构体函数 // AddServer 首字母大写，是导出的 (public) func (d *Datacenter) AddServer() { d.serverCount++ } 变量 变量声明： var a int 变量始化： 默认 var i,j int = 1,2 自动推导类型 var i,j = 1,2 短变量声明（只能在函数内使用）i,j:=1,2 没有初始化的变量会设置为对应类型的默认值 package main import "fmt" var c,python,java bool func main() { // 默认声明 var i,j int = 1,2 // 自动推导类型 var k,m = 1,2 // 短变量声明 m,o := 1,2 fmt.Println(c,python,java,i,j,l,m,o) } 基本类型 bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // uint8别名 rune // int32别名 标识 Unicode 码位 float32 float64 complex64 complex128 package main import ( "fmt" "math/cmplx" ) var ( ToBe bool = false MaxInt uint64 = 1&lt;&lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) func main() { fmt.Printf("类型：%T 值：%v\n", ToBe, ToBe) fmt.Printf("类型：%T 值：%v\n", MaxInt, MaxInt) fmt.Printf("类型：%T 值：%v\n", z, z) } 类型转换 T(v) // 将变量v转为类型T fmt.Println("%T",v) // 类型推导 const Pi = 3.14 // 常量
...</p></div><footer class=entry-footer><span title='2025-11-24 16:03:07 +0800 +0800'>2025年11月24日</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to Golang基础语法" href=https://neo-dai.github.io/posts/go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MapReduce：大型集群上的简化数据处理(英译中)</h2></header><div class=entry-content><p>本文是 《MapReduce：Simplified Data Processing on Large Clusters》 论文的中文翻译。
该论文是分布式系统领域的里程碑式工作，提出了 MapReduce 编程模型，极大地简化了大规模数据处理任务的开发难度。MapReduce 与 GFS（Google File System）和 Bigtable 并称为“Google三驾马车”，成为支撑 Google 大规模数据处理和存储的核心基础设施之一。无论你是刚入门分布式系统开发，还是希望深入理解现代大数据处理的核心思想，深入阅读和理解此文都具有重要的学习价值。
特别需要注意的是，这篇论文也是 MIT 6.824 第一讲（Lecture 1: Introduction）的核心阅读材料之一，对于打好分布式系统理论与工程实践的基础极为关键。
【免责声明】
本译文仅供个人学习与学术交流，严禁用于任何商业用途。如涉及版权问题，请即联系以便及时处理和删除。
原文链接：https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf
MapReduce：大型集群上的简化数据处理 Jeffrey Dean and Sanjay Ghemawat
jeff@google.com, sanjay@google.com
Google, Inc.
摘要 (Abstract) MapReduce is a programming model and an associ-ated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. Many real-world tasks can be expressed in this model, as shown in the paper.
...</p></div><footer class=entry-footer><span title='2025-11-22 15:44:01 +0800 +0800'>2025年11月22日</span>&nbsp;·&nbsp;<span>23 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to MapReduce：大型集群上的简化数据处理(英译中)" href=https://neo-dai.github.io/posts/mapreduce%E4%B8%AD%E8%AF%91/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[硬核] 分布式系统修炼指南：MIT 6.824 + DDIA 联合通关指南</h2></header><div class=entry-content><p>前言：为什么选择这条路？ 在分布式系统的学习路径中，有两座公认的大山：
理论圣经：《数据密集型应用系统设计》(DDIA) —— 教你"怎么选"、“怎么设计” 实践巅峰：MIT 6.824 (Distributed Systems) —— 教你"怎么做"、“怎么实现” 很多人分开学，结果往往是：看了书觉得懂了，一写代码就崩；或者闷头写代码，却不知道为什么这样设计。
💡 这份计划旨在将理论(DDIA)与实践(MIT 6.824)深度融合，助你从原本的"CRUD工程师"进阶为真正的分布式系统开发者。
0. 准备工作(预备周) 语言基础 MIT 6.824 Labs全程使用Go语言。
Action: 完成A Tour of Go
重点攻克以下Go并发原语：
// 需要熟练掌握的核心概念 - Goroutines // 轻量级线程 - Channels // 协程间通信 - Mutex/RWMutex // 互斥锁和读写锁 - sync.Cond // 条件变量 心态准备 ⚠️ 警告：这不会很容易。Lab 2(Raft)可能会让你怀疑人生，请做好心理准备。
Phase 1: 分布式系统的基石(1-2周) 目标：理解分布式存储的基本形态，习惯RPC编程。
📖 阅读(DDIA) Ch 5: Replication(复制) - 重点理解Leader-based replication，这是GFS和Raft的基础 Ch 1: Reliable, Scalable, Maintainable - 建立宏观概念 💻 课程(MIT 6.824) Lecture: MapReduce, GFS(可以只看讲义/论文，视频选看) Lab 1: MapReduce - 实现一个简单的单词计数器 重点：熟悉RPC框架 难点：适应Debug分布式程序的痛苦 ✅ 阶段目标 理解Master-Worker架构 能够使用Go的RPC库 掌握基本的分布式调试技巧 Phase 2: 核心难关——共识算法Raft(3-5周) 目标：这是整个计划中最难、含金量最高的部分。切勿求快！
...</p></div><footer class=entry-footer><span title='2025-11-21 20:11:37 +0800 +0800'>2025年11月21日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to [硬核] 分布式系统修炼指南：MIT 6.824 + DDIA 联合通关指南" href=https://neo-dai.github.io/posts/%E7%A1%AC%E6%A0%B8-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97mit-6.824-+-ddia-%E8%81%94%E5%90%88%E9%80%9A%E5%85%B3%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LeetCode01 两数之和</h2></header><div class=entry-content><p>题目描述 链接
给定一个整数数组 nums 和一个整数目标值target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
输入：nums = [3,3], target = 6 输出：[0,1]
解题思路 核心思想 使用哈希表来优化查找过程。对于当前遍历到的数nums[i]，我们需要找到target - nums[i]是否在数组中。
算法步骤 创建一个哈希表num_to_index，用于存储数值到索引的映射 遍历数组，对于每个元素nums[i]： 计算补数complement = target - nums[i] 在哈希表中查找complement是否存在 如果存在，返回[num_to_index[complement], i] 如果不存在，将当前数值和索引存入哈希表 遍历结束后返回空数组（题目保证有解，不会执行到这里） 为什么不用暴力解法？ 暴力解法需要两层循环，时间复杂度为O(n²)。而使用哈希表可以将查找时间从O(n)降到O(1)，总体时间复杂度优化到O(n)。
复杂度分析 时间复杂度: O(n)，其中n是数组长度，我们只需要遍历一次数组 空间复杂度: O(n)，哈希表最多需要存储n个元素 代码实现 C++实现 #include "leetcode.h" class Solution { public: vector&lt;int> twoSum(vector&lt;int>& nums, int target) { unordered_map&lt;int, int> num_to_index; for (int i = 0; i &lt; nums.size(); ++i) { int complement = target - nums[i]; // 查找补数是否存在 if (num_to_index.find(complement) != num_to_index.end()) { return {num_to_index[complement], i}; } // 存储当前数值和索引 num_to_index[nums[i]] = i; } return {}; } }; Go实现 package main func twoSum(nums []int, target int) []int { numToIndex := make(map[int]int) for i, num := range nums { complement := target - num // 查找补数是否存在 if idx, found := numToIndex[complement]; found { return []int{idx, i} } // 存储当前数值和索引 numToIndex[num] = i } return []int{} } Python实现 class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ num_to_index = {} for i, num in enumerate(nums): complement = target - num # 查找补数是否存在 if complement in num_to_index: return [num_to_index[complement], i] # 存储当前数值和索引 num_to_index[num] = i return [] Lua实现 function twoSum(nums, target) local num_to_index = {} for i = 1, #nums do local num = nums[i] local complement = target - num -- 查找补数是否存在 if num_to_index[complement] ~= nil then return {num_to_index[complement], i} end -- 存储当前数值和索引 num_to_index[num] = i end return {} end -- 测试代码(LeetCode平台不支持Lua，需手动测试) local nums = {2, 7, 11, 15} local target = 9 local result = twoSum(nums, target) print("输入数组:") for i = 1, #nums do io.write(nums[i] .. " ") end print("\n目标值: " .. target) print("结果索引: " .. result[1] .. ", " .. result[2]) print("验证: nums[" .. result[1] .. "] + nums[" .. result[2] .. "] = " .. nums[result[1]] .. " + " .. nums[result[2]] .. " = " .. (nums[result[1]] + nums[result[2]])) 总结 这道题是哈希表应用的经典例题，核心要点：
...</p></div><footer class=entry-footer><span title='2025-11-21 19:31:34 +0800 +0800'>2025年11月21日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to LeetCode01 两数之和" href=https://neo-dai.github.io/posts/leetcode01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AI 驱动的硬核阅读法：《Linux高性能服务器编程》读前指南</h2></header><div class=entry-content><p>今天广东降温了，早上一起来就看到昨晚谷歌宣布发布 Gemini 3，性能吊打一众 LLM，前段时间刚发布的 Grok 4 马上被反超。技术迭代之快令人咋舌，但底层的基础知识依然是那座不动的大山。
在准备攻克游双老师的《Linux高性能服务器编程》这本书之前，我决定换个思路：在这个 AI 极度强大的时代，如何让 LLM 成为我的“陪练”和“导师”，而不是简单的搜索引擎？
遂准备了几个 Prompt 投喂给 Gemini 3 Pro，得到了一份令我惊讶的深度学习路线图。这篇文章不是书评，而是一份“如何用 AI 辅助啃硬书”的实践记录。
🤖 第一步：Prompt 设计 我没有直接问知识点，而是侧重于方法论和学习路径的咨询：
角色设定与目标：我正在阅读《Linux高性能服务器编程》，在这个过程中你可以帮到我什么？ 方法论诊断：我现在的阅读方式（先通读->整理脉络->运行代码->背诵理论）是否存在问题？最佳实践是什么？ 知识蒸馏：将整本书的内容提炼精华，整理为可视化的思维导图。 🚫 痛点诊断：为什么传统的“通读”效率低？ AI 犀利地指出了我（以及大多数开发者）在学习系统编程时的误区：
❌ “通读”带来的挫败感： 前几章 TCP/IP 协议极其枯燥。如果线性通读，大概率在第 4 章就会因为枯燥而放弃。
修正：除非基础极差，否则协议部分应查阅式阅读，精力留给 API 和框架。 ❌ “运行代码”过于被动： 只是 g++ compile 然后运行看没报错，这不叫掌握。你看不见数据在内核与用户态的流动。
修正：必须引入**可观测性（Observability）**工具。（tcpdump/Wireshark/strace/lsof/netstat） ❌ “背诵记忆”是系统编程的大忌： 背诵 “TIME_WAIT 持续 2MSL” 毫无意义，过两周就忘。
修正：制造场景触发它，经历一次痛苦的 Debug，你将永生难忘。 ✅ 最佳实践：从“读者”进化为“黑客” Gemini 3 建议将学习流程升级为以下四个阶段，核心思想是**“看不见的一律不信”和“破坏式实验”**。
1. 验证式学习（Visualization） 不要只看 printf，要看内核行为。
抓包：用 tcpdump -i lo port 12345 -X，亲眼看着 SYN/ACK 包飞过去。 追踪：用 strace -p &lt;pid> 跟踪进程，观察 epoll_wait 是如何被系统触发的。 2. 破坏式实验（Destruction） 理论不要背，要去复现问题（Bug）。
...</p></div><footer class=entry-footer><span title='2025-11-19 15:55:47 +0800 +0800'>2025年11月19日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to AI 驱动的硬核阅读法：《Linux高性能服务器编程》读前指南" href=https://neo-dai.github.io/posts/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E9%98%85%E8%AF%BB%E5%89%8D/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>理解 GitHub Flow：我的极简 Git 工作流学习笔记</h2></header><div class=entry-content><p>为什么我需要一个新的 Git 工作流？ 在开始我的 MMO 服务器开发计划 时，我很快就遇到了一个问题：我该如何管理我的20个开发 “Lab”？
我最初的想法是：“为每个 Lab 创建一个分支，最后再合并到 main？”
事实证明，这个想法是完全错误的。它混淆了“过程”与“版本”。
经过一番探索，我发现了一个更简单、更强大、也是目前最主流的模式：GitHub Flow。这篇笔记就是为了记录我对这个工作流的理解。
什么是 GitHub Flow？ GitHub Flow 是一种轻量级的、基于分支的协作模式。它的哲学可以用两句话总结：
main 分支永远是神圣的。它必须在任何时刻都保持稳定、可部署。 所有的工作（新功能、Bug修复）都在临时的特性分支上进行，并通过 Pull Request (PR) 合并回 main。 没有复杂的 develop 分支，也没有冗长的 release 分支。它只有一个永恒的主干 (main) 和 N 个用完即焚的临时分支。
核心开发循环：我的实践 下面，我用我的 lab1-chatroom (聊天室) 和 lab2-movement (移动同步) 作为例子，来走一遍完整的流程。
步骤 1: 创建特性分支 永远不要、永远不要直接在 main 分支上写代码。
当我要开始做“Lab 1 聊天室”时，我首先要基于最新的 main 分支，切出一个新分支：
# 1. 确保我在 main 分支 git checkout main # 2. 拉取最新代码，确保我的 main 和远程 GitHub 上的 main 一致 git pull origin main # 3. 为我的新功能创建一个描述性的分支 git checkout -b feat/lab1-chatroom 命名规范： 我喜欢用 feat/ (功能) 或 fix/ (修复) 作为前缀，这样分支列表会非常清晰。 步骤 2: 本地开发与提交 现在，我在 feat/lab1-chatroom 这个“临时工作台”上，可以尽情地编写、调试、提交。
...</p></div><footer class=entry-footer><span title='2025-11-09 22:35:00 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 理解 GitHub Flow：我的极简 Git 工作流学习笔记" href=https://neo-dai.github.io/posts/github-flow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git和GitHub从零开始：完整开发工作流指南</h2></header><div class=entry-content><p>将 GitHub 用于版本管理，是现代软件开发的基石。它将 Git（一个强大的本地版本控制工具）与 GitHub（一个云端托管和协作平台）结合在了一起。
对于你即将开始的聊天室项目，这是一个完美的实践机会。下面我将为你分解这个过程，从零开始，直至一个规范的开发流程。
📚 核心概念：本地 vs 远程 你的电脑 (本地 - Local):
你在这里安装 Git。 你在这里编写代码（例如你的 main.go）。 你使用 git commit 来创建你代码的 “快照” 或 “存档点”。这些存档点只存在于你的电脑上。 GitHub.com (远程 - Remote):
这是一个云端服务器，你的项目“仓库”（Repository）存放在这里。 它是你所有代码的“中央真理之源” (Single Source of Truth)，也是你与他人（或你自己的其他设备）同步代码的地方。 你使用 git push 将你本地的 “快照” 推送到 GitHub。 你使用 git pull 将 GitHub 上的最新 “快照” 拉取到你的电脑。 🚀 步骤一：一次性设置 (The “Once-Off” Setup) 你只需要做这些一次。
安装 Git: 如果你还没有安装，请访问 git-scm.com 下载并安装。 创建 GitHub 账户: 访问 GitHub.com 注册一个免费账户。 配置 Git (本地): 打开你的终端（Terminal / 命令行），告诉 Git 你是谁。这样你的 “快照” 才能被署名。 git config --global user.name "Your Name" git config --global user.email "your.email@example.com" 📈 步骤二：启动你的聊天室项目 这是最推荐的“从零开始”的流程。
...</p></div><footer class=entry-footer><span title='2025-11-09 21:57:08 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to Git和GitHub从零开始：完整开发工作流指南" href=https://neo-dai.github.io/posts/git%E5%92%8Cgithub%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%8C%E6%95%B4%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%8C%87%E5%8D%97/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://neo-dai.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://neo-dai.github.io/>Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default",securityLevel:"loose"}),document.querySelectorAll(".mermaid").length>0&&mermaid.run()</script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>