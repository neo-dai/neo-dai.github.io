<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | myblog</title><meta name=keywords content><meta name=description content="Posts - myblog"><meta name=author content="neo"><link rel=canonical href=https://neo-dai.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://neo-dai.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://neo-dai.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://neo-dai.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://neo-dai.github.io/apple-touch-icon.png><link rel=mask-icon href=https://neo-dai.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://neo-dai.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://neo-dai.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://neo-dai.github.io/posts/"><meta property="og:site_name" content="myblog"><meta property="og:title" content="Posts"><meta property="og:description" content="CodeLabs"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="CodeLabs"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://neo-dai.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://neo-dai.github.io/ accesskey=h title="myblog (Alt + H)">myblog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://neo-dai.github.io/ title=首页><span>首页</span></a></li><li><a href=https://neo-dai.github.io/posts/ title=文章><span class=active>文章</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>理解 GitHub Flow：我的极简 Git 工作流学习笔记</h2></header><div class=entry-content><p>为什么我需要一个新的 Git 工作流？ 在开始我的 MMO 服务器开发计划 (这里你可以链向你的另一篇博文) 时，我很快就遇到了一个问题：我该如何管理我的20个开发 “Lab”？
我最初的想法是：“为每个 Lab 创建一个分支，最后再合并到 main？”
事实证明，这个想法是完全错误的。它混淆了“过程”与“版本”。
经过一番探索，我发现了一个更简单、更强大、也是目前最主流的模式：GitHub Flow。这篇笔记就是为了记录我对这个工作流的理解。
什么是 GitHub Flow？ GitHub Flow 是一种轻量级的、基于分支的协作模式。它的哲学可以用两句话总结：
main 分支永远是神圣的。它必须在任何时刻都保持稳定、可部署。 所有的工作（新功能、Bug修复）都在临时的特性分支上进行，并通过 Pull Request (PR) 合并回 main。 没有复杂的 develop 分支，也没有冗长的 release 分支。它只有一个永恒的主干 (main) 和 N 个用完即焚的临时分支。
核心开发循环：我的实践 下面，我用我的 lab1-chatroom (聊天室) 和 lab2-movement (移动同步) 作为例子，来走一遍完整的流程。
步骤 1: 创建特性分支 永远不要、永远不要直接在 main 分支上写代码。
当我要开始做“Lab 1 聊天室”时，我首先要基于最新的 main 分支，切出一个新分支：
# 1. 确保我在 main 分支 git checkout main # 2. 拉取最新代码，确保我的 main 和远程 GitHub 上的 main 一致 git pull origin main # 3. 为我的新功能创建一个描述性的分支 git checkout -b feat/lab1-chatroom 命名规范： 我喜欢用 feat/ (功能) 或 fix/ (修复) 作为前缀，这样分支列表会非常清晰。 步骤 2: 本地开发与提交 现在，我在 feat/lab1-chatroom 这个“临时工作台”上，可以尽情地编写、调试、提交。
...</p></div><footer class=entry-footer><span title='2025-11-09 22:35:00 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 理解 GitHub Flow：我的极简 Git 工作流学习笔记" href=https://neo-dai.github.io/posts/github-flow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git和GitHub从零开始：完整开发工作流指南</h2></header><div class=entry-content><p>将 GitHub 用于版本管理，是现代软件开发的基石。它将 Git（一个强大的本地版本控制工具）与 GitHub（一个云端托管和协作平台）结合在了一起。
对于你即将开始的聊天室项目，这是一个完美的实践机会。下面我将为你分解这个过程，从零开始，直至一个规范的开发流程。
📚 核心概念：本地 vs 远程 你的电脑 (本地 - Local):
你在这里安装 Git。 你在这里编写代码（例如你的 main.go）。 你使用 git commit 来创建你代码的 “快照” 或 “存档点”。这些存档点只存在于你的电脑上。 GitHub.com (远程 - Remote):
这是一个云端服务器，你的项目“仓库”（Repository）存放在这里。 它是你所有代码的“中央真理之源” (Single Source of Truth)，也是你与他人（或你自己的其他设备）同步代码的地方。 你使用 git push 将你本地的 “快照” 推送到 GitHub。 你使用 git pull 将 GitHub 上的最新 “快照” 拉取到你的电脑。 🚀 步骤一：一次性设置 (The “Once-Off” Setup) 你只需要做这些一次。
安装 Git: 如果你还没有安装，请访问 git-scm.com 下载并安装。 创建 GitHub 账户: 访问 GitHub.com 注册一个免费账户。 配置 Git (本地): 打开你的终端（Terminal / 命令行），告诉 Git 你是谁。这样你的 “快照” 才能被署名。 git config --global user.name "Your Name" git config --global user.email "your.email@example.com" 📈 步骤二：启动你的聊天室项目 这是最推荐的“从零开始”的流程。
...</p></div><footer class=entry-footer><span title='2025-11-09 21:57:08 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to Git和GitHub从零开始：完整开发工作流指南" href=https://neo-dai.github.io/posts/git%E5%92%8Cgithub%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%8C%E6%95%B4%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用GitHub Action 自动化部署blog</h2></header><div class=entry-content><p>在日常写博客时，如果每次都需要本地执行 hugo 构建命令、进入 public 目录、再手动 git push，效率低且易出错。现代开发讲究 CI/CD（持续集成/持续部署），其实我们能完全自动化博客发布，让你专注写 Markdown，其余交给 GitHub Actions 实现自动部署。
前后流程对比 在进入详细流程前，先来看博客部署的前后对比流程图：
🕹️ 传统手动部署流程 graph TD A[写 Markdown] --> B[本地 hugo 构建] B --> C[进入 public 目录] C --> D[git add/commit/push 到 pages 仓库] D --> E[博客发布上线] 🚀 自动化部署（CI/CD）流程 graph TD A[写 Markdown] --> B[git push 到源码仓库] B --> C[触发 GitHub Actions 自动构建] C --> D[Actions 自动生成静态网页] D --> E[Actions 自动推送到 pages 仓库] E --> F[博客发布上线] 可以看到，自动化部署后，你只需要写好 Markdown 并 git push，其它琐事全部交给自动流水线，极大提高效率和安全性。
...</p></div><footer class=entry-footer><span title='2025-11-09 17:45:35 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 使用GitHub Action 自动化部署blog" href=https://neo-dai.github.io/posts/%E4%BA%8C%E4%BD%BF%E7%94%A8github-action-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2blog/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用Hugo+GitHub Page快速搭建个人博客</h2></header><div class=entry-content><p>在本教程中，你将学会如何利用 Hugo（一个高效的静态网站生成器）和 GitHub Pages 免费快速搭建属于你自己的个人博客。全流程覆盖从环境安装、写作、主题美化，到部署上线，适合对前端不熟悉、但愿意动手实践的你！
为什么选择 Hugo + GitHub Pages？ Markdown 写作体验：用最简洁的 Markdown 语法写文章，专注内容本身。 极速编译 & 性能：Hugo 生成网站几乎是秒级，生成的全是静态页面，加载飞快。 免费托管：GitHub Pages 提供免费高速 CDN，无需额外服务器。 极客成长路径：包含 Git 版本管理、CI/CD 自动化部署，堪称“小型全栈实践”。 安全性强：纯静态页面，无数据库、PHP 后台减少潜在攻击面。 搭建步骤 1. 安装 Hugo macOS:
brew install hugo
Windows:
推荐用 choco install hugo-extended，或到 Hugo Releases 下载适合的 .exe 二进制包。
2. 新建博客项目 在任意文件夹下执行：
hugo new site my-blog cd my-blog 结构简介：
content/：所有文章（Markdown 格式）都放这里。 themes/：博客主题目录。 static/：静态资源如图片、CSS。 config.toml：全局配置文件。 3. 安装和配置主题 浏览并挑选心仪主题：Hugo 主题站（推荐 ananke、even、stack 等）。
用 Git 添加主题为子模块（以 ananke 为例）：
...</p></div><footer class=entry-footer><span title='2025-11-09 17:22:55 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 使用Hugo+GitHub Page快速搭建个人博客" href=https://neo-dai.github.io/posts/%E4%B8%80%E4%BD%BF%E7%94%A8hugo+github-page%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>游戏开发之旅</h2></header><div class=entry-content><p>在学习mmorpg服务器开发时有哪些小项目可以用来练手？ 这是一个非常棒的学习目标！开发MMORPG服务器可以说是后端开发中复杂度最高、挑战最大的领域之一。
“MMORPG”和“小项目”这两个词组合在一起是有些矛盾的，因为MMO的核心就在于“Massively”（大规模）。但你的“练手”思路非常正确：不要一开始就想构建一个完整的“魔兽世界”，而是应该把MMO服务器拆解成一个个核心组件，然后针对这些组件进行专项练习。
这里为你设计了5个由浅入深的“练手”小项目，它们可以独立完成，也能最终组合起来：
基础练手：多人聊天室（WebSocket / TCP）
这是MMO服务器的“Helloworld”。所有MMO都离不开网络通信和状态广播。
项目目标：实现一个支持多房间、支持公屏和私聊的聊天服务器。
核心功能：
用户连接：客户端（可以用简单的命令行，或者一个网页）可以连接到服务器。 身份验证：简单的用户名密码登录（甚至可以只是输入一个昵称）。 大厅广播：一个用户发消息，所有在线用户都能收到。 频道/房间：用户可以加入不同“频道”（如 /join trade），只接收该频道的消息。 私聊：用户可以指定另一个用户发送消息（如 /w username message）。 MMO关联技能：
网络编程：掌握 TCP 或 WebSocket，了解 Socket 编程。 连接管理：如何维护一个“在线用户列表”（Connection Pool）。 消息广播：如何高效地把一条消息推送给成百上千个连接。 协议设计：定义简单的消息格式（例如用JSON或Protobuf：{type: "broadcast", message: "..."}）。 2. 核心进阶：MUD风格的移动同步服务器 MUD（Multi-User Dungeon）是MMORPG的文字版鼻祖。这个项目将帮你掌握MMO最核心的“状态同步”。
项目目标：在一个2D网格地图上，实现多个玩家的位置同步。
核心功能：
服务器逻辑：服务器内存中维护一个二维数组（例如 100x100）作为地图。 玩家进入：玩家登录后，在地图上（例如[50, 50]）出生。 权威服务器（Authoritative Server）： 客户端发送“意图”（如 “我想往北走”）。 服务器验证这个移动是否合法（例如，是否撞墙？是否在CD中？）。 如果合法，服务器更新内存中该玩家的坐标（例如 player.x += 1）。 状态广播：服务器只把这个“玩家A移动到了[50, 51]”的消息广播给附近的其他玩家。 MMO关联技能：
权威服务器架构：这是防外挂的根本。逻辑在服务器计算，客户端只负责渲染。 状态同步：如何保持服务器和所有客户端的数据一致性。 视野管理（AoI - Area of Interest）：理解为什么“只广播给附近玩家”至关重要，这是节省带宽和服务器性能的关键。 3. 数据持久化：角色创建与背包系统 游戏数据不能只在内存里，关服就没了。这个项目练习的是与数据库的交互。
项目目标：实现玩家的角色创建、登录，以及一个简单的背包。
核心功能：
数据库设计：设计几张表：accounts (账号密码)、characters (角色名、职业、等级、坐标)、inventory (哪个角色拥有哪个物品ID、数量)。 角色创建：客户端发来创建请求，服务器验证（如名字是否重复）后，写入数据库。 角色登录：玩家登录后，服务器从数据库读取角色数据，加载到内存中。 背包操作： 模拟“捡起物品”：给玩家背包（内存）增加一个物品。 模拟“丢弃物品”：从背包（内存）移除一个物品。 数据落地：玩家下线时，或每隔5分钟，将内存中的背包、坐标等数据存回数据库。 MMO关联技能：
...</p></div><footer class=entry-footer><span title='2025-11-09 00:37:03 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 游戏开发之旅" href=https://neo-dai.github.io/posts/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E6%97%85/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>在Hugo中配置Mermaid图表支持</h2></header><div class=entry-content><p>Mermaid是一个强大的图表和流程图生成工具，可以通过简单的文本语法创建各种图表。在Hugo博客中集成Mermaid支持，可以让你在Markdown文章中直接绘制流程图、时序图、甘特图等，极大提升技术文档的可读性和专业性。
为什么选择Mermaid？ 纯文本语法：使用Markdown类似的语法，无需图形界面工具 版本控制友好：图表代码可以像代码一样进行版本管理 多种图表类型：支持流程图、时序图、甘特图、类图、状态图等 自动渲染：在浏览器中自动渲染为SVG矢量图 配置流程概览 在Hugo中配置Mermaid支持的整体流程如下：
graph TD A[开始配置] --> B[创建Render Hook] B --> C[添加Mermaid脚本] C --> D[配置Hugo Markup] D --> E[测试渲染] E --> F{渲染成功?} F -->|是| G[完成配置] F -->|否| H[排查问题] H --> D 详细配置步骤 1. 创建Mermaid Render Hook Hugo使用Render Hook来自定义代码块的渲染方式。我们需要创建一个专门的hook来处理mermaid代码块。
在项目根目录下创建以下文件：
文件路径：layouts/_default/_markup/render-codeblock-mermaid.html
文件内容：
&lt;div class="mermaid"> {{- .Inner -}} &lt;/div> 这个文件的作用是：当Hugo遇到 ```mermaid 代码块时，会将其转换为 &lt;div class="mermaid"> 元素，而不是普通的代码块。
2. 添加Mermaid JavaScript支持 接下来需要在页面中加载Mermaid的JavaScript库，并初始化渲染。
文件路径：layouts/partials/extend_footer.html
文件内容：
{{- /* Footer custom content area start */ -}} {{- /* 添加Mermaid支持 */ -}} &lt;script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js">&lt;/script> &lt;script> // 初始化mermaid并渲染页面中的所有mermaid图表 mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'loose' }); // 确保所有mermaid元素都被渲染 if (document.querySelectorAll('.mermaid').length > 0) { mermaid.run(); } &lt;/script> {{- /* Footer custom content area end */ -}} 说明：
...</p></div><footer class=entry-footer><span title='2025-01-27 10:00:00 +0800 +0800'>2025年1月27日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 在Hugo中配置Mermaid图表支持" href=https://neo-dai.github.io/posts/%E4%B8%89%E5%9C%A8hugo%E4%B8%AD%E9%85%8D%E7%BD%AEmermaid%E5%9B%BE%E8%A1%A8%E6%94%AF%E6%8C%81/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://neo-dai.github.io/>myblog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default",securityLevel:"loose"}),document.querySelectorAll(".mermaid").length>0&&mermaid.run()</script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>