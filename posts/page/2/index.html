<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Notes</title><meta name=keywords content><meta name=description content="Posts - Notes"><meta name=author content="neo"><link rel=canonical href=https://neo-dai.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.b4dfb58bc1aadc21cb0542f53df82233971252c1283b7ff385ac519b35b25bc3.css integrity="sha256-tN+1i8Gq3CHLBUL1PfgiM5cSUsEoO3/zhaxRmzWyW8M=" rel="preload stylesheet" as=style><link rel=icon href=https://neo-dai.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://neo-dai.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://neo-dai.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://neo-dai.github.io/apple-touch-icon.png><link rel=mask-icon href=https://neo-dai.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://neo-dai.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://neo-dai.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500;600;700&display=swap" rel=stylesheet><meta property="og:url" content="https://neo-dai.github.io/posts/"><meta property="og:site_name" content="Notes"><meta property="og:title" content="Posts"><meta property="og:description" content="CodeLabs"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="CodeLabs"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://neo-dai.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://neo-dai.github.io/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://neo-dai.github.io/ title=首页><span>首页</span></a></li><li><a href=https://neo-dai.github.io/posts/ title=文章><span class=active>文章</span></a></li><li><a href=https://neo-dai.github.io/series/ title=专栏><span>专栏</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[硬核] 分布式系统修炼指南：MIT 6.824 + DDIA 联合通关指南</h2></header><div class=entry-content><p>前言：为什么选择这条路？ 在分布式系统的学习路径中，有两座公认的大山：
理论圣经：《数据密集型应用系统设计》(DDIA) —— 教你"怎么选"、“怎么设计” 实践巅峰：MIT 6.824 (Distributed Systems) —— 教你"怎么做"、“怎么实现” 很多人分开学，结果往往是：看了书觉得懂了，一写代码就崩；或者闷头写代码，却不知道为什么这样设计。
💡 这份计划旨在将理论(DDIA)与实践(MIT 6.824)深度融合，助你从原本的"CRUD工程师"进阶为真正的分布式系统开发者。
0. 准备工作(预备周) 语言基础 MIT 6.824 Labs全程使用Go语言。
Action: 完成A Tour of Go
重点攻克以下Go并发原语：
// 需要熟练掌握的核心概念 - Goroutines // 轻量级线程 - Channels // 协程间通信 - Mutex/RWMutex // 互斥锁和读写锁 - sync.Cond // 条件变量 心态准备 ⚠️ 警告：这不会很容易。Lab 2(Raft)可能会让你怀疑人生，请做好心理准备。
Phase 1: 分布式系统的基石(1-2周) 目标：理解分布式存储的基本形态，习惯RPC编程。
📖 阅读(DDIA) Ch 5: Replication(复制) - 重点理解Leader-based replication，这是GFS和Raft的基础 Ch 1: Reliable, Scalable, Maintainable - 建立宏观概念 💻 课程(MIT 6.824) Lecture: MapReduce, GFS(可以只看讲义/论文，视频选看) Lab 1: MapReduce - 实现一个简单的单词计数器 重点：熟悉RPC框架 难点：适应Debug分布式程序的痛苦 ✅ 阶段目标 理解Master-Worker架构 能够使用Go的RPC库 掌握基本的分布式调试技巧 Phase 2: 核心难关——共识算法Raft(3-5周) 目标：这是整个计划中最难、含金量最高的部分。切勿求快！
...</p></div><footer class=entry-footer><span title='2025-11-21 20:11:37 +0800 +0800'>2025年11月21日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to [硬核] 分布式系统修炼指南：MIT 6.824 + DDIA 联合通关指南" href=https://neo-dai.github.io/posts/%E7%A1%AC%E6%A0%B8-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97mit-6.824-+-ddia-%E8%81%94%E5%90%88%E9%80%9A%E5%85%B3%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LeetCode01 两数之和</h2></header><div class=entry-content><p>题目描述 链接
给定一个整数数组 nums 和一个整数目标值target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
输入：nums = [3,3], target = 6 输出：[0,1]
解题思路 核心思想 使用哈希表来优化查找过程。对于当前遍历到的数nums[i]，我们需要找到target - nums[i]是否在数组中。
算法步骤 创建一个哈希表num_to_index，用于存储数值到索引的映射 遍历数组，对于每个元素nums[i]： 计算补数complement = target - nums[i] 在哈希表中查找complement是否存在 如果存在，返回[num_to_index[complement], i] 如果不存在，将当前数值和索引存入哈希表 遍历结束后返回空数组（题目保证有解，不会执行到这里） 为什么不用暴力解法？ 暴力解法需要两层循环，时间复杂度为O(n²)。而使用哈希表可以将查找时间从O(n)降到O(1)，总体时间复杂度优化到O(n)。
复杂度分析 时间复杂度: O(n)，其中n是数组长度，我们只需要遍历一次数组 空间复杂度: O(n)，哈希表最多需要存储n个元素 代码实现 C++实现 #include "leetcode.h" class Solution { public: vector&lt;int> twoSum(vector&lt;int>& nums, int target) { unordered_map&lt;int, int> num_to_index; for (int i = 0; i &lt; nums.size(); ++i) { int complement = target - nums[i]; // 查找补数是否存在 if (num_to_index.find(complement) != num_to_index.end()) { return {num_to_index[complement], i}; } // 存储当前数值和索引 num_to_index[nums[i]] = i; } return {}; } }; Go实现 package main func twoSum(nums []int, target int) []int { numToIndex := make(map[int]int) for i, num := range nums { complement := target - num // 查找补数是否存在 if idx, found := numToIndex[complement]; found { return []int{idx, i} } // 存储当前数值和索引 numToIndex[num] = i } return []int{} } Python实现 class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ num_to_index = {} for i, num in enumerate(nums): complement = target - num # 查找补数是否存在 if complement in num_to_index: return [num_to_index[complement], i] # 存储当前数值和索引 num_to_index[num] = i return [] Lua实现 function twoSum(nums, target) local num_to_index = {} for i = 1, #nums do local num = nums[i] local complement = target - num -- 查找补数是否存在 if num_to_index[complement] ~= nil then return {num_to_index[complement], i} end -- 存储当前数值和索引 num_to_index[num] = i end return {} end -- 测试代码(LeetCode平台不支持Lua，需手动测试) local nums = {2, 7, 11, 15} local target = 9 local result = twoSum(nums, target) print("输入数组:") for i = 1, #nums do io.write(nums[i] .. " ") end print("\n目标值: " .. target) print("结果索引: " .. result[1] .. ", " .. result[2]) print("验证: nums[" .. result[1] .. "] + nums[" .. result[2] .. "] = " .. nums[result[1]] .. " + " .. nums[result[2]] .. " = " .. (nums[result[1]] + nums[result[2]])) 总结 这道题是哈希表应用的经典例题，核心要点：
...</p></div><footer class=entry-footer><span title='2025-11-21 19:31:34 +0800 +0800'>2025年11月21日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to LeetCode01 两数之和" href=https://neo-dai.github.io/posts/leetcode01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AI 驱动的硬核阅读法：《Linux高性能服务器编程》读前指南</h2></header><div class=entry-content><p>今天广东降温了，早上一起来就看到昨晚谷歌宣布发布 Gemini 3，性能吊打一众 LLM，前段时间刚发布的 Grok 4 马上被反超。技术迭代之快令人咋舌，但底层的基础知识依然是那座不动的大山。
在准备攻克游双老师的《Linux高性能服务器编程》这本书之前，我决定换个思路：在这个 AI 极度强大的时代，如何让 LLM 成为我的“陪练”和“导师”，而不是简单的搜索引擎？
遂准备了几个 Prompt 投喂给 Gemini 3 Pro，得到了一份令我惊讶的深度学习路线图。这篇文章不是书评，而是一份“如何用 AI 辅助啃硬书”的实践记录。
🤖 第一步：Prompt 设计 我没有直接问知识点，而是侧重于方法论和学习路径的咨询：
角色设定与目标：我正在阅读《Linux高性能服务器编程》，在这个过程中你可以帮到我什么？ 方法论诊断：我现在的阅读方式（先通读->整理脉络->运行代码->背诵理论）是否存在问题？最佳实践是什么？ 知识蒸馏：将整本书的内容提炼精华，整理为可视化的思维导图。 🚫 痛点诊断：为什么传统的“通读”效率低？ AI 犀利地指出了我（以及大多数开发者）在学习系统编程时的误区：
❌ “通读”带来的挫败感： 前几章 TCP/IP 协议极其枯燥。如果线性通读，大概率在第 4 章就会因为枯燥而放弃。
修正：除非基础极差，否则协议部分应查阅式阅读，精力留给 API 和框架。 ❌ “运行代码”过于被动： 只是 g++ compile 然后运行看没报错，这不叫掌握。你看不见数据在内核与用户态的流动。
修正：必须引入**可观测性（Observability）**工具。（tcpdump/Wireshark/strace/lsof/netstat） ❌ “背诵记忆”是系统编程的大忌： 背诵 “TIME_WAIT 持续 2MSL” 毫无意义，过两周就忘。
修正：制造场景触发它，经历一次痛苦的 Debug，你将永生难忘。 ✅ 最佳实践：从“读者”进化为“黑客” Gemini 3 建议将学习流程升级为以下四个阶段，核心思想是**“看不见的一律不信”和“破坏式实验”**。
1. 验证式学习（Visualization） 不要只看 printf，要看内核行为。
抓包：用 tcpdump -i lo port 12345 -X，亲眼看着 SYN/ACK 包飞过去。 追踪：用 strace -p &lt;pid> 跟踪进程，观察 epoll_wait 是如何被系统触发的。 2. 破坏式实验（Destruction） 理论不要背，要去复现问题（Bug）。
...</p></div><footer class=entry-footer><span title='2025-11-19 15:55:47 +0800 +0800'>2025年11月19日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to AI 驱动的硬核阅读法：《Linux高性能服务器编程》读前指南" href=https://neo-dai.github.io/posts/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E9%98%85%E8%AF%BB%E5%89%8D/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>理解 GitHub Flow：我的极简 Git 工作流学习笔记</h2></header><div class=entry-content><p>为什么我需要一个新的 Git 工作流？ 在开始我的 MMO 服务器开发计划 时，我很快就遇到了一个问题：我该如何管理我的20个开发 “Lab”？
我最初的想法是：“为每个 Lab 创建一个分支，最后再合并到 main？”
事实证明，这个想法是完全错误的。它混淆了“过程”与“版本”。
经过一番探索，我发现了一个更简单、更强大、也是目前最主流的模式：GitHub Flow。这篇笔记就是为了记录我对这个工作流的理解。
什么是 GitHub Flow？ GitHub Flow 是一种轻量级的、基于分支的协作模式。它的哲学可以用两句话总结：
main 分支永远是神圣的。它必须在任何时刻都保持稳定、可部署。 所有的工作（新功能、Bug修复）都在临时的特性分支上进行，并通过 Pull Request (PR) 合并回 main。 没有复杂的 develop 分支，也没有冗长的 release 分支。它只有一个永恒的主干 (main) 和 N 个用完即焚的临时分支。
核心开发循环：我的实践 下面，我用我的 lab1-chatroom (聊天室) 和 lab2-movement (移动同步) 作为例子，来走一遍完整的流程。
步骤 1: 创建特性分支 永远不要、永远不要直接在 main 分支上写代码。
当我要开始做“Lab 1 聊天室”时，我首先要基于最新的 main 分支，切出一个新分支：
# 1. 确保我在 main 分支 git checkout main # 2. 拉取最新代码，确保我的 main 和远程 GitHub 上的 main 一致 git pull origin main # 3. 为我的新功能创建一个描述性的分支 git checkout -b feat/lab1-chatroom 命名规范： 我喜欢用 feat/ (功能) 或 fix/ (修复) 作为前缀，这样分支列表会非常清晰。 步骤 2: 本地开发与提交 现在，我在 feat/lab1-chatroom 这个“临时工作台”上，可以尽情地编写、调试、提交。
...</p></div><footer class=entry-footer><span title='2025-11-09 22:35:00 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 理解 GitHub Flow：我的极简 Git 工作流学习笔记" href=https://neo-dai.github.io/posts/github-flow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git和GitHub从零开始：完整开发工作流指南</h2></header><div class=entry-content><p>将 GitHub 用于版本管理，是现代软件开发的基石。它将 Git（一个强大的本地版本控制工具）与 GitHub（一个云端托管和协作平台）结合在了一起。
对于你即将开始的聊天室项目，这是一个完美的实践机会。下面我将为你分解这个过程，从零开始，直至一个规范的开发流程。
📚 核心概念：本地 vs 远程 你的电脑 (本地 - Local):
你在这里安装 Git。 你在这里编写代码（例如你的 main.go）。 你使用 git commit 来创建你代码的 “快照” 或 “存档点”。这些存档点只存在于你的电脑上。 GitHub.com (远程 - Remote):
这是一个云端服务器，你的项目“仓库”（Repository）存放在这里。 它是你所有代码的“中央真理之源” (Single Source of Truth)，也是你与他人（或你自己的其他设备）同步代码的地方。 你使用 git push 将你本地的 “快照” 推送到 GitHub。 你使用 git pull 将 GitHub 上的最新 “快照” 拉取到你的电脑。 🚀 步骤一：一次性设置 (The “Once-Off” Setup) 你只需要做这些一次。
安装 Git: 如果你还没有安装，请访问 git-scm.com 下载并安装。 创建 GitHub 账户: 访问 GitHub.com 注册一个免费账户。 配置 Git (本地): 打开你的终端（Terminal / 命令行），告诉 Git 你是谁。这样你的 “快照” 才能被署名。 git config --global user.name "Your Name" git config --global user.email "your.email@example.com" 📈 步骤二：启动你的聊天室项目 这是最推荐的“从零开始”的流程。
...</p></div><footer class=entry-footer><span title='2025-11-09 21:57:08 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to Git和GitHub从零开始：完整开发工作流指南" href=https://neo-dai.github.io/posts/git%E5%92%8Cgithub%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%8C%E6%95%B4%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用GitHub Action 自动化部署blog</h2></header><div class=entry-content><p>在日常写博客时，如果每次都需要本地执行 hugo 构建命令、进入 public 目录、再手动 git push，效率低且易出错。现代开发讲究 CI/CD（持续集成/持续部署），其实我们能完全自动化博客发布，让你专注写 Markdown，其余交给 GitHub Actions 实现自动部署。
前后流程对比 在进入详细流程前，先来看博客部署的前后对比流程图：
🕹️ 传统手动部署流程 graph TD A[写 Markdown] --> B[本地 hugo 构建] B --> C[进入 public 目录] C --> D[git add/commit/push 到 pages 仓库] D --> E[博客发布上线] 🚀 自动化部署（CI/CD）流程 graph TD A[写 Markdown] --> B[git push 到源码仓库] B --> C[触发 GitHub Actions 自动构建] C --> D[Actions 自动生成静态网页] D --> E[Actions 自动推送到 pages 仓库] E --> F[博客发布上线] 可以看到，自动化部署后，你只需要写好 Markdown 并 git push，其它琐事全部交给自动流水线，极大提高效率和安全性。
...</p></div><footer class=entry-footer><span title='2025-11-09 17:45:35 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 使用GitHub Action 自动化部署blog" href=https://neo-dai.github.io/posts/%E4%BA%8C%E4%BD%BF%E7%94%A8github-action-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2blog/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用Hugo+GitHub Page快速搭建个人博客</h2></header><div class=entry-content><p>在本教程中，你将学会如何利用 Hugo（一个高效的静态网站生成器）和 GitHub Pages 免费快速搭建属于你自己的个人博客。全流程覆盖从环境安装、写作、主题美化，到部署上线，适合对前端不熟悉、但愿意动手实践的你！
为什么选择 Hugo + GitHub Pages？ Markdown 写作体验：用最简洁的 Markdown 语法写文章，专注内容本身。 极速编译 & 性能：Hugo 生成网站几乎是秒级，生成的全是静态页面，加载飞快。 免费托管：GitHub Pages 提供免费高速 CDN，无需额外服务器。 极客成长路径：包含 Git 版本管理、CI/CD 自动化部署，堪称“小型全栈实践”。 安全性强：纯静态页面，无数据库、PHP 后台减少潜在攻击面。 搭建步骤 1. 安装 Hugo macOS:
brew install hugo
Windows:
推荐用 choco install hugo-extended，或到 Hugo Releases 下载适合的 .exe 二进制包。
2. 新建博客项目 在任意文件夹下执行：
hugo new site my-blog cd my-blog 结构简介：
content/：所有文章（Markdown 格式）都放这里。 themes/：博客主题目录。 static/：静态资源如图片、CSS。 config.toml：全局配置文件。 3. 安装和配置主题 浏览并挑选心仪主题：Hugo 主题站（推荐 ananke、even、stack 等）。
用 Git 添加主题为子模块（以 ananke 为例）：
...</p></div><footer class=entry-footer><span title='2025-11-09 17:22:55 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 使用Hugo+GitHub Page快速搭建个人博客" href=https://neo-dai.github.io/posts/%E4%B8%80%E4%BD%BF%E7%94%A8hugo+github-page%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>游戏开发之旅</h2></header><div class=entry-content><p>在学习mmorpg服务器开发时有哪些小项目可以用来练手？ 这是一个非常棒的学习目标！开发MMORPG服务器可以说是后端开发中复杂度最高、挑战最大的领域之一。
“MMORPG”和“小项目”这两个词组合在一起是有些矛盾的，因为MMO的核心就在于“Massively”（大规模）。但你的“练手”思路非常正确：不要一开始就想构建一个完整的“魔兽世界”，而是应该把MMO服务器拆解成一个个核心组件，然后针对这些组件进行专项练习。
这里为你设计了5个由浅入深的“练手”小项目，它们可以独立完成，也能最终组合起来：
基础练手：多人聊天室（WebSocket / TCP）
这是MMO服务器的“Helloworld”。所有MMO都离不开网络通信和状态广播。
项目目标：实现一个支持多房间、支持公屏和私聊的聊天服务器。
核心功能：
用户连接：客户端（可以用简单的命令行，或者一个网页）可以连接到服务器。 身份验证：简单的用户名密码登录（甚至可以只是输入一个昵称）。 大厅广播：一个用户发消息，所有在线用户都能收到。 频道/房间：用户可以加入不同“频道”（如 /join trade），只接收该频道的消息。 私聊：用户可以指定另一个用户发送消息（如 /w username message）。 MMO关联技能：
网络编程：掌握 TCP 或 WebSocket，了解 Socket 编程。 连接管理：如何维护一个“在线用户列表”（Connection Pool）。 消息广播：如何高效地把一条消息推送给成百上千个连接。 协议设计：定义简单的消息格式（例如用JSON或Protobuf：{type: "broadcast", message: "..."}）。 2. 核心进阶：MUD风格的移动同步服务器 MUD（Multi-User Dungeon）是MMORPG的文字版鼻祖。这个项目将帮你掌握MMO最核心的“状态同步”。
项目目标：在一个2D网格地图上，实现多个玩家的位置同步。
核心功能：
服务器逻辑：服务器内存中维护一个二维数组（例如 100x100）作为地图。 玩家进入：玩家登录后，在地图上（例如[50, 50]）出生。 权威服务器（Authoritative Server）： 客户端发送“意图”（如 “我想往北走”）。 服务器验证这个移动是否合法（例如，是否撞墙？是否在CD中？）。 如果合法，服务器更新内存中该玩家的坐标（例如 player.x += 1）。 状态广播：服务器只把这个“玩家A移动到了[50, 51]”的消息广播给附近的其他玩家。 MMO关联技能：
权威服务器架构：这是防外挂的根本。逻辑在服务器计算，客户端只负责渲染。 状态同步：如何保持服务器和所有客户端的数据一致性。 视野管理（AoI - Area of Interest）：理解为什么“只广播给附近玩家”至关重要，这是节省带宽和服务器性能的关键。 3. 数据持久化：角色创建与背包系统 游戏数据不能只在内存里，关服就没了。这个项目练习的是与数据库的交互。
项目目标：实现玩家的角色创建、登录，以及一个简单的背包。
核心功能：
数据库设计：设计几张表：accounts (账号密码)、characters (角色名、职业、等级、坐标)、inventory (哪个角色拥有哪个物品ID、数量)。 角色创建：客户端发来创建请求，服务器验证（如名字是否重复）后，写入数据库。 角色登录：玩家登录后，服务器从数据库读取角色数据，加载到内存中。 背包操作： 模拟“捡起物品”：给玩家背包（内存）增加一个物品。 模拟“丢弃物品”：从背包（内存）移除一个物品。 数据落地：玩家下线时，或每隔5分钟，将内存中的背包、坐标等数据存回数据库。 MMO关联技能：
...</p></div><footer class=entry-footer><span title='2025-11-09 00:37:03 +0800 +0800'>2025年11月9日</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 游戏开发之旅" href=https://neo-dai.github.io/posts/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E6%97%85/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>在Hugo中配置Mermaid图表支持</h2></header><div class=entry-content><p>Mermaid是一个强大的图表和流程图生成工具，可以通过简单的文本语法创建各种图表。在Hugo博客中集成Mermaid支持，可以让你在Markdown文章中直接绘制流程图、时序图、甘特图等，极大提升技术文档的可读性和专业性。
为什么选择Mermaid？ 纯文本语法：使用Markdown类似的语法，无需图形界面工具 版本控制友好：图表代码可以像代码一样进行版本管理 多种图表类型：支持流程图、时序图、甘特图、类图、状态图等 自动渲染：在浏览器中自动渲染为SVG矢量图 配置流程概览 在Hugo中配置Mermaid支持的整体流程如下：
graph TD A[开始配置] --> B[创建Render Hook] B --> C[添加Mermaid脚本] C --> D[配置Hugo Markup] D --> E[测试渲染] E --> F{渲染成功?} F -->|是| G[完成配置] F -->|否| H[排查问题] H --> D 详细配置步骤 1. 创建Mermaid Render Hook Hugo使用Render Hook来自定义代码块的渲染方式。我们需要创建一个专门的hook来处理mermaid代码块。
在项目根目录下创建以下文件：
文件路径：layouts/_default/_markup/render-codeblock-mermaid.html
文件内容：
&lt;div class="mermaid"> {{- .Inner -}} &lt;/div> 这个文件的作用是：当Hugo遇到 ```mermaid 代码块时，会将其转换为 &lt;div class="mermaid"> 元素，而不是普通的代码块。
2. 添加Mermaid JavaScript支持 接下来需要在页面中加载Mermaid的JavaScript库，并初始化渲染。
文件路径：layouts/partials/extend_footer.html
文件内容：
{{- /* Footer custom content area start */ -}} {{- /* 添加Mermaid支持 */ -}} &lt;script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js">&lt;/script> &lt;script> // 初始化mermaid并渲染页面中的所有mermaid图表 mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'loose' }); // 确保所有mermaid元素都被渲染 if (document.querySelectorAll('.mermaid').length > 0) { mermaid.run(); } &lt;/script> {{- /* Footer custom content area end */ -}} 说明：
...</p></div><footer class=entry-footer><span title='2025-01-27 10:00:00 +0800 +0800'>2025年1月27日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 在Hugo中配置Mermaid图表支持" href=https://neo-dai.github.io/posts/%E4%B8%89%E5%9C%A8hugo%E4%B8%AD%E9%85%8D%E7%BD%AEmermaid%E5%9B%BE%E8%A1%A8%E6%94%AF%E6%8C%81/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://neo-dai.github.io/posts/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://neo-dai.github.io/>Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default",securityLevel:"loose"}),document.querySelectorAll(".mermaid").length>0&&mermaid.run()</script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>