<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.152.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Notes</title><meta name=description content="CodeLabs"><meta name=author content="neo"><link rel=canonical href=https://neo-dai.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.b4dfb58bc1aadc21cb0542f53df82233971252c1283b7ff385ac519b35b25bc3.css integrity="sha256-tN+1i8Gq3CHLBUL1PfgiM5cSUsEoO3/zhaxRmzWyW8M=" rel="preload stylesheet" as=style><link rel=icon href=https://neo-dai.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://neo-dai.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://neo-dai.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://neo-dai.github.io/apple-touch-icon.png><link rel=mask-icon href=https://neo-dai.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://neo-dai.github.io/index.xml title=rss><link rel=alternate hreflang=en href=https://neo-dai.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500;600;700&display=swap" rel=stylesheet><meta property="og:url" content="https://neo-dai.github.io/"><meta property="og:site_name" content="Notes"><meta property="og:title" content="Notes"><meta property="og:description" content="CodeLabs"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Notes"><meta name=twitter:description content="CodeLabs"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Notes","url":"https://neo-dai.github.io/","description":"CodeLabs","logo":"https://neo-dai.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://neo-dai.github.io/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://neo-dai.github.io/ title=首页><span class=active>首页</span></a></li><li><a href=https://neo-dai.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://neo-dai.github.io/series/ title=专栏><span>专栏</span></a></li></ul></nav></header><main class=main><article class=first-entry><header class=entry-header><h2 class=entry-hint-parent>LeetCode128最长连续序列</h2></header><div class=entry-content><p>一、题目描述 题目链接
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
示例 1：
**输入：**nums = [100,4,200,1,3,2] **输出：**4 **解释：**最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：
**输入：**nums = [0,3,7,2,5,8,4,6,0,1] **输出：**9
示例 3：
**输入：**nums = [1,0,1,2] **输出：**3
提示：
0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 二、解题思路 核心思想 💡利用hash表查找时间复杂度为$O(1)$的特性来快速找到当前元素+1 算法步骤 将列表填入hash表（自动去重） 遍历hash表， 如果当前元素不是序列的开始则跳过，避免重复查找 反之则从当前元素开始不断的查找下一个curr_nums+1 每论查找结束后更新当前最长连续序列 思路 一开始看到求最长连续序列时就想到了直接std::sort后一轮循环搞定，但题目要求在$O(n)$的时间复杂内搞定，这套显然不行。遂思考其他方法。 发现问题的本质实际上是需要快速的查找的当前数字的+1，于是就只能使用哈希表了，且可以利用当前元素是否为序列起始数字来避免重复查找 三、 复杂度分析 时间复杂度: O(n) 空间复杂度: O(n) 四、代码实现 C++实现 class Solution { public: // 方法一：哈希表 int longestConsecutive(vector&lt;int>& nums) { if (nums.size() == 0) return 0; unordered_set&lt;int> st; for (int num : nums) st.insert(num); int max_len = 0; for (int num : st) { // 只从连续序列的起点开始计算 if (st.count(num - 1)) continue; // 从起点开始向后扩展 int current_len = 1; int current_num = num; while (st.count(current_num + 1)) { current_len++; current_num++; } max_len = max(max_len, current_len); } return max_len; } // 方法二：排序法 int longestConsecutive2(vector&lt;int>& nums) { if (nums.size() == 0) return 0; // 排序 sort(nums.begin(),nums.end()); // 去重 nums.erase(std::unique(nums.begin(), nums.end()), nums.end()); int max_len = 1; int tmp_len = 1; for(int i = 1; i&lt; nums.size(); ++i ) { if (nums[i-1] + 1 == nums[i]) { tmp_len++; if (tmp_len > max_len) { max_len = tmp_len; } } else { tmp_len = 1; } } return max_len; } }; int main() { Solution solution; vector&lt;int> nums = {9,1,4,7,3,-1,0,5,8,-1,6}; int result = solution.longestConsecutive(nums); cout &lt;&lt; result &lt;&lt; endl; return 0; } golang 实现 func longestConsecutive(nums []int) int { if len(nums) == 0 { return 0 } // 构建哈希表 mp := make(map[int]bool) for _, num := range nums { mp[num] = true } // 找出最长的连续字段 maxLen := 0 for num := range mp { // 避免重复遍历: 如果num-1存在，则num不是连续字段的起点，跳过 if mp[num-1] { continue } // 以num为起点，计算连续字段的长度 curNum := num curLen := 1 for mp[curNum+1] { curNum++ curLen++ } if curLen > maxLen { maxLen = curLen } } return maxLen } func longestConsecutive2(nums []int) int { if len(nums) &lt;= 0 { return 0 } // 1. 排序 sort.Ints(nums) // 2. 找出最长的连续字段 tmp_len := 1 max_len := 1 for i := 1; i &lt; len(nums); i++ { if nums[i] == nums[i-1] { continue } else if nums[i] == nums[i-1]+1 { tmp_len++ if tmp_len > max_len { max_len = tmp_len } } else { tmp_len = 1 } } return max_len } func main() { nums := []int{9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6} result := longestConsecutive(nums) println(result) } 五、 总结 利用哈希表实现 $O(1)$ 时间复杂度的查找，通过只从序列起点开始计算避免重复遍历。</p></div><footer class=entry-footer><span title='2025-12-12 13:26:36 +0800 +0800'>2025年12月12日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to LeetCode128最长连续序列" href=https://neo-dai.github.io/posts/leetcode128%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>《A Tour of Go》golang中的数组、slice、map</h2></header><div class=entry-content><p>tour.golang.org
数组 var 数组名 [数组长度] 数组类型
package main import "fmt" func main() { var a [2]string // c++: string a[2]; a[0] = "Hello" a[1] = "World" fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int{2, 3, 5, 7, 11, 13} fmt.Println(primes) } slice(切片) 💡 类似c++中的std::vector 支持动态扩容,且本质是一个结构体 记录了指向底层数组的指针、长度、容量 {arr_point,len,cap}
1. 切片与数组的区别、切片的增删查改 // 数组 直接存储3个int值 长度不可变,数据在栈上 var arr [3]int = [3]int{1, 2, 3} fmt.Println(arr) // 切片 s实际上是一个结构体{arr_point,len,cap} 类似c++ std::vector 支持动态扩容 s := []int{1, 2, 3} fmt.Println("原始切片:", s, "len:", len(s), "cap:", cap(s)) // === 增（Append）=== // 1. 追加单个元素（类似 C++ vector.push_back） s = append(s, 17) fmt.Println("追加17:", s) // 2. 追加多个元素 s = append(s, 19, 23, 29) fmt.Println("追加多个:", s) // 3. 追加另一个切片（需要 ... 展开） s2 := []int{31, 37} s = append(s, s2...) fmt.Println("追加切片:", s) // === 查（Access）=== // 直接通过索引访问，O(1) 时间复杂度 fmt.Println("索引3的元素:", s[3]) // === 改（Modify）=== // 直接通过索引修改 s[0] = 100 fmt.Println("修改索引0:", s) // === 删（Delete）=== // Go 没有内置删除函数，需要通过切片操作 // 1. 删除索引为2的元素 i := 2 s = append(s[:i], s[i+1:]...) fmt.Println("删除索引2:", s) // 2. 删除最后一个元素（类似 C++ vector.pop_back） s = s[:len(s)-1] fmt.Println("删除最后:", s) // === 切片操作（Slicing）=== // 这是 Go 特有的，C++ 需要用迭代器 sub := s[2:5] // 获取索引 2-4 的元素（左闭右开） fmt.Println("子切片[2:5]:", sub) // === 创建切片的方式 === // 1. 使用 make 创建指定长度和容量的切片 s3 := make([]int, 5) // 长度5，容量5，初始值都是0 fmt.Println("make(len=5):", s3, "len:", len(s3), "cap:", cap(s3)) s4 := make([]int, 3, 10) // 长度3，容量10 fmt.Println("make(len=3,cap=10):", s4, "len:", len(s4), "cap:", cap(s4)) 2. 对数组切片后，扩容切片超过原数组后会与原数组断开关联 // 创建一个长度为5的数组 arr := [5]int{1, 2, 3, 4, 5} fmt.Printf("原数组: %v, 地址: %p\n", arr, &amp;arr) fmt.Printf("切片: %v, len=%d, cap=%d\n", arr, len(arr), cap(arr)) // 对数组进行切片，取前3个元素 slice := arr[0:3] // 等价与 [:3] fmt.Printf("\n--- 初始切片 ---\n") fmt.Printf("切片: %v, len=%d, cap=%d\n", slice, len(slice), cap(slice)) fmt.Printf("切片第一个元素地址: %p\n", &amp;slice[0]) fmt.Printf("原数组第一个元素地址: %p\n", &amp;arr[0]) fmt.Println("此时切片和原数组共享底层数组:", &amp;slice[0] == &amp;arr[0]) // 修改切片会影响原数组 slice[0] = 100 fmt.Printf("\n--- 修改 slice[0] = 100 ---\n") fmt.Printf("切片: %v\n", slice) fmt.Printf("原数组: %v (原数组也被修改了)\n", arr) // 在容量范围内append，仍然使用原数组 fmt.Printf("\n--- 在容量范围内 append ---\n") fmt.Printf("当前 len=%d, cap=%d, 还可以在原数组上追加 %d 个元素\n", len(slice), cap(slice), cap(slice)-len(slice)) slice = append(slice, 6) fmt.Printf("append(slice, 6) 后: %v, len=%d, cap=%d\n", slice, len(slice), cap(slice)) fmt.Printf("切片第一个元素地址: %p\n", &amp;slice[0]) fmt.Println("仍然共享底层数组:", &amp;slice[0] == &amp;arr[0]) fmt.Printf("原数组: %v (arr[3] 被覆盖了)\n", arr) slice = append(slice, 7) fmt.Printf("append(slice, 7) 后: %v, len=%d, cap=%d\n", slice, len(slice), cap(slice)) fmt.Printf("原数组: %v (arr[4] 被覆盖了)\n", arr) // 超过容量，触发扩容，使用新的底层数组 fmt.Printf("\n--- 超过容量，触发扩容 ---\n") fmt.Printf("当前 len=%d, cap=%d, 继续 append 将超过容量\n", len(slice), cap(slice)) oldAddr := &amp;slice[0] slice = append(slice, 8) newAddr := &amp;slice[0] fmt.Printf("append(slice, 8) 后: %v, len=%d, cap=%d\n", slice, len(slice), cap(slice)) fmt.Printf("扩容前第一个元素地址: %p\n", oldAddr) fmt.Printf("扩容后第一个元素地址: %p\n", newAddr) fmt.Println("地址发生变化，使用了新的底层数组:", oldAddr != newAddr) // 现在修改切片不会影响原数组 fmt.Printf("\n--- 验证切片已与原数组分离 ---\n") slice[0] = 999 fmt.Printf("修改 slice[0] = 999\n") fmt.Printf("切片: %v\n", slice) fmt.Printf("原数组: %v (原数组不受影响)\n", arr) 3. 切片的零值（默认值）是 nil var s []int fmt.Println(s, len(s), cap(s)) if s == nil { fmt.Println("nil!") } map(映射） 基于hash表实现：（Go1.19及以后哈希冲突解决主要采用拉链法（数组+链表/红黑树）） 无序：每次遍历元素的顺序可能不同 查找效率高：查找、插入、删除的平均时间复杂度为$O(1)$ ， 最坏的情况下退化到$O(n)$ key必须唯一： 同一个键多次赋值，后者覆盖前者 key必须可比较 零值(nil)：可读但不可写（会引发panic） 扩容：提前指定预估初始容量可以减少扩容带来的性能损耗 make(map[KeyType]ValueType, initialCappacity) 非并发安全：多个goroutine 并发对同一个map读写会导致panic map 的定义、初始化、以及增删查改 package main import "fmt" func main() { fmt.Println("=== Go Map 基础教程 ===\n") // 1. 创建 map 的几种方式 // 【与 C++ 对比】 // Go: scores := make(map[string]int) // C++: std::unordered_map&lt;std::string, int> scores; // // 主要差异： // - Go 使用 make() 函数或字面量语法，语法更简洁 // - C++ 需要模板参数 &lt;Key, Value> // - Go 的 map 是引用类型，C++ 的 unordered_map 是值类型 // - Go 可以预分配容量：make(map[string]int, 100) // - C++ 使用 reserve(): scores.reserve(100) fmt.Println("1. 创建 map:") // 方式1: 使用 make 创建 scores := make(map[string]int) fmt.Printf("空 map: %v\n", scores) // 方式2: 字面量初始化 // 【与 C++ 对比】 // Go: ages := map[string]int{"张三": 25, "李四": 30} // C++: std::unordered_map&lt;std::string, int> ages = {{"张三", 25}, {"李四", 30}}; // C++ 使用双层大括号，Go 使用冒号分隔键值 ages := map[string]int{ "张三": 25, "李四": 30, "王五": 28, } fmt.Printf("初始化的 map: %v\n\n", ages) // 2. 增加元素（直接赋值） // 【与 C++ 对比】 // Go: scores["数学"] = 95 // C++: scores["数学"] = 95; 或 scores.insert({"数学", 95}); // // 主要差异： // - 两者语法类似，都支持 [] 操作符直接赋值 // - C++ 还有 insert(), emplace() 等方法 // - Go 的 [] 操作符会自动处理增加和修改 // - C++ 的 insert() 如果键已存在则不会覆盖，[] 会覆盖 fmt.Println("2. 增加元素:") scores["数学"] = 95 scores["语文"] = 88 scores["英语"] = 92 fmt.Printf("添加后: %v\n\n", scores) // 3. 查询元素 // 【与 C++ 对比】 // Go: value := scores["数学"] // C++: int value = scores["数学"]; // 不存在会插入默认值 // int value = scores.at("数学"); // 不存在会抛异常 // // 主要差异： // - Go 的 [] 访问不存在的键返回零值（0, "", nil 等），不会报错 // - C++ 的 [] 访问不存在的键会插入该键并返回默认值 // - C++ 的 at() 访问不存在的键会抛出 std::out_of_range 异常 // - Go 使用 value, ok := map[key] 来检查键是否存在 // - C++ 使用 find() 返回迭代器，或 contains() (C++20) fmt.Println("3. 查询元素:") // 直接访问 mathScore := scores["数学"] fmt.Printf("数学成绩: %d\n", mathScore) // 安全查询（检查键是否存在） // Go 特有的语法：返回值和存在标志 // C++ 等价: auto it = scores.find("语文"); if (it != scores.end()) { ... } chineseScore, exists := scores["语文"] if exists { fmt.Printf("语文成绩: %d (存在)\n", chineseScore) } // 查询不存在的键 physicsScore, exists := scores["物理"] if !exists { fmt.Printf("物理成绩不存在，返回零值: %d\n\n", physicsScore) } // 4. 修改元素 // 【与 C++ 对比】 // Go 和 C++ 在修改元素时语法完全一致 // Go: scores["数学"] = 98 // C++: scores["数学"] = 98; // // 注意：Go 的 [] 操作符不区分增加和修改，统一使用赋值语法 fmt.Println("4. 修改元素:") fmt.Printf("修改前数学成绩: %d\n", scores["数学"]) scores["数学"] = 98 fmt.Printf("修改后数学成绩: %d\n\n", scores["数学"]) // 5. 删除元素 // 【与 C++ 对比】 // Go: delete(scores, "英语") // C++: scores.erase("英语"); // // 主要差异： // - Go 使用内置函数 delete(map, key)，无返回值 // - C++ 使用成员方法 erase(key)，返回删除的元素个数 // - 两者删除不存在的键都不会报错/panic // - C++ 还支持通过迭代器删除: scores.erase(it); fmt.Println("5. 删除元素:") fmt.Printf("删除前: %v\n", scores) delete(scores, "英语") fmt.Printf("删除英语后: %v\n", scores) // 删除不存在的键不会报错 delete(scores, "不存在的科目") fmt.Printf("删除不存在的键后: %v\n\n", scores) // 6. 获取 map 长度 // 【与 C++ 对比】 // Go: len(scores) // C++: scores.size() // // 主要差异： // - Go 使用内置函数 len()，适用于所有集合类型 // - C++ 使用成员方法 size() // - C++ 还有 empty() 方法检查是否为空 // - Go 可以直接用 len(map) == 0 检查 fmt.Println("6. 获取长度:") fmt.Printf("scores 的长度: %d\n", len(scores)) fmt.Printf("ages 的长度: %d\n\n", len(ages)) // 7. 遍历 map // 【与 C++ 对比】 // Go: for key, value := range scores { ... } // C++: for (const auto& [key, value] : scores) { ... } // C++17 结构化绑定 // for (auto it = scores.begin(); it != scores.end(); ++it) { ... } // // 主要差异： // - Go 使用 range 关键字，语法更简洁 // - C++ 可以使用结构化绑定（C++17）或迭代器 // - 两者遍历顺序都是不确定的（unordered） // - Go 每次运行遍历顺序可能不同（故意随机化） // - C++ 的顺序取决于哈希实现，但同一次运行中稳定 fmt.Println("7. 遍历 map:") fmt.Println("遍历 scores:") for subject, score := range scores { fmt.Printf(" %s: %d\n", subject, score) } fmt.Println("\n遍历 ages:") for name, age := range ages { fmt.Printf(" %s: %d 岁\n", name, age) } fmt.Println() // 8. 只遍历键或值 // 【与 C++ 对比】 // Go 只遍历键: for key := range scores { ... } // Go 只遍历值: for _, value := range scores { ... } // // C++ 只遍历键: for (const auto& [key, _] : scores) { ... } // C++ 只遍历值: for (const auto& [_, value] : scores) { ... } // // 主要差异： // - Go 使用 _ 忽略不需要的值，语法更清晰 // - C++ 也可以用 [[maybe_unused]] 或直接不使用变量 // - Go 省略第二个变量就只遍历键 // - C++ 需要完整的结构化绑定语法 fmt.Println("8. 只遍历键或值:") fmt.Print("所有科目: ") for subject := range scores { fmt.Printf("%s ", subject) } fmt.Println() fmt.Print("所有分数: ") for _, score := range scores { fmt.Printf("%d ", score) } fmt.Println("\n") // 9. 检查键是否存在 // 【与 C++ 对比】 // Go: if _, ok := scores["数学"]; ok { ... } // C++: if (scores.find("数学") != scores.end()) { ... } // if (scores.contains("数学")) { ... } // C++20 // if (scores.count("数学") > 0) { ... } // 旧方式 // // 主要差异： // - Go 使用逗号ok惯用法 (comma ok idiom)，返回值和布尔标志 // - C++ 使用 find() 返回迭代器，需要与 end() 比较 // - C++20 新增 contains() 方法，返回 bool，更接近 Go 的语义 // - Go 的方式更简洁，一行代码同时获取值和检查存在性 // - C++ 的 count() 对于 unordered_map 只返回 0 或 1 fmt.Println("9. 检查键是否存在:") if _, ok := scores["数学"]; ok { fmt.Println("数学成绩存在") } if _, ok := scores["物理"]; !ok { fmt.Println("物理成绩不存在") } fmt.Println() // 10. map 的零值和清空 // 【与 C++ 对比】 // Go: var emptyMap map[string]int // nil map // C++: std::unordered_map&lt;std::string, int> emptyMap; // 空 map，不是 null // // 主要差异： // - Go 的 map 零值是 nil，可以读取但不能写入（会 panic） // - C++ 的 unordered_map 没有 null 概念，声明即可用 // - Go 需要显式初始化才能写入: make(map[K]V) 或字面量 // - C++ 的默认构造函数自动创建可用的空 map // // 清空操作： // Go: myMap = make(map[string]int) // 重新分配 // 或遍历删除: for k := range myMap { delete(myMap, k) } // C++: myMap.clear(); // 有专门的清空方法 fmt.Println("10. map 的零值:") var emptyMap map[string]int fmt.Printf("未初始化的 map: %v (nil: %v)\n", emptyMap, emptyMap == nil) // 注意：nil map 可以读取，但不能写入 // emptyMap["key"] = 1 // 这会 panic // 清空 map（重新赋值） scores = make(map[string]int) fmt.Printf("清空后的 map: %v\n\n", scores) // 11. 复杂类型作为值 // 【与 C++ 对比】 // Go: map[int]Student // C++: std::unordered_map&lt;int, Student> // // 主要差异： // - Go 的结构体作为值时是值拷贝，修改需要重新赋值整个结构体 // 例如: s := students[1001]; s.Age = 20; students[1001] = s // - C++ 也是值拷贝，但可以通过引用修改: students[1001].Age = 20; // - Go 如果需要修改，建议使用指针: map[int]*Student // - C++ 可以用 emplace() 原地构造，避免拷贝 // // 注意：Go 不能直接修改 map 中结构体的字段 // students[1001].Age = 20 // 编译错误！ fmt.Println("11. 复杂类型的 map:") // map 的值可以是结构体 type Student struct { Name string Age int Grade int } students := map[int]Student{ 1001: {"张三", 18, 90}, 1002: {"李四", 19, 85}, } fmt.Printf("学生信息: %v\n", students) fmt.Printf("学号 1001: %v\n\n", students[1001]) // 12. map 嵌套 // 【与 C++ 对比】 // Go: map[string]map[string]int // C++: std::unordered_map&lt;std::string, std::unordered_map&lt;std::string, int>> // // 主要差异： // - 语法类似，但 C++ 的模板嵌套更冗长 // - Go 初始化内层 map 时语法更简洁 // - 注意：访问不存在的外层键时，Go 返回 nil map，访问会 panic // 建议先检查: if inner, ok := outer["key"]; ok { ... } // - C++ 的 [] 会自动创建不存在的键 fmt.Println("12. map 嵌套:") classScores := map[string]map[string]int{ "一班": { "张三": 90, "李四": 85, }, "二班": { "王五": 92, "赵六": 88, }, } fmt.Printf("班级成绩: %v\n", classScores) fmt.Printf("一班张三的成绩: %d\n", classScores["一班"]["张三"]) // ======================================== // 【Go map vs C++ unordered_map 总结对比】 // ======================================== // // 1. 类型系统： // - Go: map 是引用类型，传递时不拷贝数据 // - C++: unordered_map 是值类型，传递时拷贝（可用引用优化） // // 2. 线程安全： // - Go: map 不是线程安全的，需要 sync.Mutex 或 sync.Map // - C++: unordered_map 不是线程安全的，需要自行加锁 // // 3. 键的要求： // - Go: 键必须是可比较类型（支持 ==），不能是 slice、map、function // - C++: 键必须有 hash 函数和 == 运算符 // // 4. 性能特点： // - Go: 哈希表实现，平均 O(1)，自动扩容 // - C++: 哈希表实现，平均 O(1)，可以自定义 hash 和 load factor // // 5. 内存管理： // - Go: 自动垃圾回收，删除元素不一定立即释放内存 // - C++: 手动管理（RAII），删除元素立即释放内存 // // 6. 迭代顺序： // - Go: 故意随机化，每次运行可能不同 // - C++: 不确定但同一次运行中相对稳定 // // 7. 零值/空值： // - Go: nil map 可读不可写，需要先 make // - C++: 默认构造即可用，无 null 概念 // // 8. 常用操作对比表： // ┌─────────────┬──────────────────────────┬────────────────────────────────┐ // │ 操作 │ Go │ C++ │ // ├─────────────┼──────────────────────────┼────────────────────────────────┤ // │ 创建 │ make(map[K]V) │ unordered_map&lt;K,V> m; │ // │ 添加/修改 │ m[k] = v │ m[k] = v; │ // │ 查询 │ v := m[k] │ v = m[k]; │ // │ 安全查询 │ v, ok := m[k] │ auto it = m.find(k); │ // │ 存在性检查 │ _, ok := m[k] │ m.contains(k) // C++20 │ // │ 删除 │ delete(m, k) │ m.erase(k); │ // │ 长度 │ len(m) │ m.size() │ // │ 清空 │ m = make(map[K]V) │ m.clear(); │ // │ 遍历 │ for k, v := range m {...}│ for(auto& [k,v]:m){...} │ // └─────────────┴──────────────────────────┴────────────────────────────────┘ // // 9. 何时选择： // - Go map: 简洁易用，适合大多数场景，需要垃圾回收的项目 // - C++ unordered_map: 需要更精细的内存控制，性能关键路径 // // 10. 实用建议： // Go: // - 总是检查 nil map 再写入 // - 使用 comma-ok 惯用法检查键存在性 // - 需要并发访问时使用 sync.Map 或加锁 // - 如果需要有序遍历，考虑先排序键 // // C++: // - 传递 map 时使用 const& 避免拷贝 // - 使用 emplace() 原地构造提高性能 // - 需要有序遍历使用 std::map 而不是 unordered_map // - C++20 优先使用 contains() 而不是 find() fmt.Println("\n=== 教程结束 ===") }</p></div><footer class=entry-footer><span title='2025-12-11 17:50:13 +0800 +0800'>2025年12月11日</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 《A Tour of Go》golang中的数组、slice、map" href=https://neo-dai.github.io/posts/a-tour-of-gogolang%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84slicemap/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>《A Tour of Go》golang的基础语法</h2></header><div class=entry-content><p>tour.golang.org
package & import 每个程序都是由包构成，main本身也是一个package 可以通过import导入其他包来使用 package main import ( "fmt" "math/rand" ) func main() { fmt.Println("我最喜欢的数字是 ", rand.Intn(10)) fmt.Println("rand.Intn(20)") } 导出名（Exported） package 中 首字母大写的字段可以给其他包直接访问，反之则不行 package infrastructure // Datacenter 结构体是导出的 (public) type Datacenter struct { // serverCount 首字母小写，是未导出的 (private) // 只有 infrastructure 包内部的代码能访问它 serverCount int } // AddServer 首字母大写，是导出的 (public) func (d *Datacenter) AddServer() { d.serverCount++ } 函数 基础函数 func add(x int, y int) int { return x + y } 函数参数类型简写 func add(x , y int) int { return x + y } 多返回值 func swap(x, y string) (string, string) { return y, x } // swap 函数调用示例 func main() { a, b := swap("hello", "world") fmt.Println(a, b) // 输出: world hello } 带名字的返回值 func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } // split 函数调用示例 func main() { x, y := split(17) fmt.Println(x, y) // 输出: 7 10 } 结构体函数 // Datacenter 结构体和 AddServer 方法的完整示例 package main import "fmt" // Datacenter 定义 type Datacenter struct { serverCount int } // AddServer 首字母大写，是导出的 (public) func (d *Datacenter) AddServer() { d.serverCount++ } func main() { dc := &amp;Datacenter{} // 创建一个 Datacenter 实例 fmt.Println("初始服务器数：", dc.serverCount) // dc.serverCount 可以直接访问是因为在同一个package内 dc.AddServer() fmt.Println("添加服务器后：", dc.serverCount) dc.AddServer() fmt.Println("再添加一次后：", dc.serverCount) } 变量 变量声明： var a int 变量初始化： 默认 var i,j int = 1,2 自动推导类型 var i,j = 1,2 短变量声明（只能在函数内使用）i,j:=1,2 没有初始化的变量会设置为对应类型的默认值 package main import "fmt" var c,python,java bool func main() { // 默认声明 var i,j int = 1,2 // 自动推导类型 var k,m = 1,2 // 短变量声明 n,o := 1,2 fmt.Println(c,python,java,i,j,k,m,n,o) } 基本类型 bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // uint8别名 rune // int32别名 标识 Unicode 码位 float32 float64 complex64 complex128 package main import ( "fmt" "math/cmplx" ) var ( ToBe bool = false MaxInt uint64 = 1&lt;&lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) func main() { fmt.Printf("类型：%T 值：%v\n", ToBe, ToBe) fmt.Printf("类型：%T 值：%v\n", MaxInt, MaxInt) fmt.Printf("类型：%T 值：%v\n", z, z) } 类型转换 T(v) // 将变量v转为类型T fmt.Println("%T",v) // 类型推导 const Pi = 3.14 // 常量
...</p></div><footer class=entry-footer><span title='2025-12-11 17:46:13 +0800 +0800'>2025年12月11日</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 《A Tour of Go》golang的基础语法" href=https://neo-dai.github.io/posts/a-tour-of-gogolang%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++迭代器失效场景总结</h2></header><div class=entry-content><p>目录 1. 什么是迭代器失效 2. vector的迭代器失效 3. deque的迭代器失效 4. list的迭代器失效 5. map/set的迭代器失效 6. unordered_map/unordered_set的迭代器失效 7. 迭代器失效的预防措施 8. 总结表格 1. 什么是迭代器失效 迭代器失效是指当容器的内部结构发生改变时，原有的迭代器可能变得不再有效，继续使用会导致未定义行为，包括程序崩溃、数据错误等。
迭代器失效的主要原因：
容器扩容（导致内存重新分配） 元素插入/删除（改变容器内部结构） 容器被移动或销毁 2. vector的迭代器失效 2.1 插入操作导致失效 场景1：push_back导致扩容
#include &lt;vector> #include &lt;iostream> void example_vector_pushback() { std::vector&lt;int> vec = {1, 2, 3, 4, 5}; vec.reserve(5); // 容量为5 auto it = vec.begin(); auto it_mid = vec.begin() + 2; // 指向第3个元素 std::cout &lt;&lt; "扩容前: *it_mid = " &lt;&lt; *it_mid &lt;&lt; std::endl; // 输出: 3 vec.push_back(6); // 触发扩容！ // ❌ 危险！it和it_mid已经失效 // std::cout &lt;&lt; *it_mid &lt;&lt; std::endl; // 未定义行为 } 失效原因：
push_back导致vector扩容时，会重新分配内存 所有元素被复制到新的内存位置 所有迭代器、指针、引用全部失效 场景2：insert操作
void example_vector_insert() { std::vector&lt;int> vec = {1, 2, 3, 4, 5}; auto it = vec.begin() + 2; // 指向值为3的元素 // 在位置1插入元素 vec.insert(vec.begin() + 1, 99); // ❌ it已经失效！ // 即使没有扩容，insert之后的所有迭代器都会失效 } 失效规则：
...</p></div><footer class=entry-footer><span title='2025-12-11 17:27:25 +0800 +0800'>2025年12月11日</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to C++迭代器失效场景总结" href=https://neo-dai.github.io/posts/c++%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LeetCode49 字母异位词分组</h2></header><div class=entry-content><p>一、题目描述 leetcode链接
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
字母异位词 : 字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。
示例 1:
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: “[["bat"],["nat","tan"],["ate","eat","tea"]]”
解释：
在 strs 中没有字符串可以通过重新排列来形成 "bat"。 字符串 "nat" 和 "tan" 是字母异位词，因为它们可以重新排列以形成彼此。 字符串 "ate" ，"eat" 和 "tea" 是字母异位词，因为它们可以重新排列以形成彼此。 示例 2:
输入: strs = [""]
输出: [[""]]
示例 3:
输入: strs = ["a"]
输出: [[“a”]]
提示：
1 &lt;= strs.length &lt;= 104 0 &lt;= strs[i].length &lt;= 100 strs[i] 仅包含小写字母 二、解题思路 核心思想 同类型的字符串仅仅字母顺序不同，意味着将其排序后就可以作为hash表索引，实现快速找到自己的分组 算法步骤 构建索引：遍历一遍strs将字符串排序后拿到索引，并使用索引找到hash表中分组的位置实现插入 构建结果：将hash表以题目要求的方式返回 优化 既然是以字符串为索引 且小写字母只有26个， 那就可以使用字母出现的次数作为索引，这样就不用给每个字符串排序了，在单个字符串非常长的情况下效果显著 三、 复杂度分析 排序法 时间复杂度: $O(n \times k \log k)$，n 是数组长度，k 是字符串长度 空间复杂度: $O(n \times k)$，存储 n 个字符串作为 value，最多 n 个 key（每个 key 长度为 k） 计数法 时间复杂度：$O(n \times k)$ 空间复杂度：$O(n \times k)$ 四、代码实现 C++实现 （耗时：1h20min） class Solution { public: // 计数法 vector&lt;vector&lt;string>> groupAnagrams(vector&lt;string>& strs) { // 1. 构建索引 unordered_map&lt;string,vector&lt;string>> tmp; for (const auto& str : strs) { string key(26,'0'); for (const char& c : str ) { key[c-'a']++; } tmp[key].push_back(str); } // 2. 构建结果 vector&lt;vector&lt;string>> result; result.reserve(tmp.size()); for (auto& it : tmp) { result.push_back(std::move(it.second)); } // 3. 返回结果 return result; } // 排序法 vector&lt;vector&lt;string>> groupAnagrams2(vector&lt;string>& strs) { // 1. 构建索引 unordered_map&lt;string,vector&lt;string>> tmp; for (const auto& str : strs) { string key = str; sort(key.begin(),key.end()); tmp[key].push_back(str); } // 2. 构建结果 vector&lt;vector&lt;string>> result; result.reserve(tmp.size()); for (auto& it : tmp) { // tips： 使用 std::move 来避免大量字符串 vector 的深拷贝 result.push_back(std::move(it.second)); } // 3. 返回结果 return result; } }; go 实现 // 排序法 func groupAnagrams(strs []string) [][]string { // 1. 构建索引（排序法） // 由于 sort 无法直接排序 string，需要转换为 []byte mp := make(map[string][]string) for _, str := range strs { b := []byte(str) sort.Slice(b, func(i, j int) bool { return b[i] &lt; b[j] }) key := string(b) mp[key] = append(mp[key], str) } // 2. 构建结果 result := make([][]string, 0, len(mp)) for _, v := range mp { result = append(result, v) } return result } // 计数法 func groupAnagrams2(strs []string) [][]string { // 1. 构建索引 mp := make(map[[26]int][]string) for _, str := range strs { // tips: 需要注意的是str仅仅为值拷贝，并非引用 如果需要修改数组元素需要访问strs[i] var count [26]int for _, c := range str { count[c-'a']++ } mp[count] = append(mp[count], str) } // 2. 构建结果 // tips: 使用make提前预分配容量可以显著减少内存分配和数据复制 result := make([][]string, 0, len(mp)) for _, v := range mp { result = append(result, v) } return result } 五、 总结 核心逻辑：映射（Mapping）
...</p></div><footer class=entry-footer><span title='2025-12-10 17:51:34 +0800 +0800'>2025年12月10日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to LeetCode49 字母异位词分组" href=https://neo-dai.github.io/posts/leetcode49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AI使用技巧（开篇）</h2></header><div class=entry-content><p>前言 用了很久 AI，起初我只是把它当作一个更聪明的搜索引擎，或者偶尔用来生成点代码片段的工具。但随着接触的 AI 应用越来越多，我发现它带来的改变远超预期：
在代码侧：开发模式从传统“设计-开发-自测”的执行者，进化为一名 Tech Lead，指挥着多个 AI Agent 协作流转、Agent之间通过文件实现交流： Agent 1 负责和我把需求与设计聊透并将具体实施方案的Prompt写入文件(ClaudeOpus4.5 Think)； Agent 2 读取方案后负责以“小步迭代”的形式分步实现，并确保单元测试覆盖(ClaudeSonnet4.5)； Agent 3 负责构建、测试与反馈(ClaudeSonnet3.5)。 在学习侧：AI 成了最好的私人导师。它拥有海量知识库的同时又充满耐心，能帮我快速啃下分布式系统、源码分析等硬骨头。 在生活侧：它甚至像一面镜子。当我把日记交给 Cursor 管理时，它总能精准地指出我思维中的盲区和潜在问题，并给出非常可行的改进建议；或者没事就和豆包打电话聊天，它是生活中的百事通。 因此，系统性地学习如何更好地使用 AI 是一件极具价值的事情。于是我准备开启这个 Blog 系列——这既是 AI 的建议，也是费曼学习法的一次实践，通过输出倒逼输入，完成知识的内化。
施工计划 (Roadmap) AI 使用技巧(一)：如何高效与AI对话
提示词技巧 AI时代的《提问的智慧》 AI 使用技巧(二)： Cursor使用技巧
AI 使用技巧(三)： ClaudeCode使用技巧
AI 使用技巧(四): Vibe Coding技巧
多Agent合作，高效的同时最大化节省Token 如何避免AI”偷懒“ 如何快速熟悉新项目或应对复杂历史遗留代码 复杂日志分析与debug AI 使用技巧(五): 如何利用AI快速掌握一个新的技能
使用AI导师辅助学习Golang 使用AI导师辅助学习MIT6.824(天坑难度) AI 使用技巧(六): 如何“训练”一个专属于自己的AI
项目知识库问答AI定制 Talk is cheap, I will show you the prompt. 持续更新中…</p></div><footer class=entry-footer><span title='2025-11-28 17:13:13 +0800 +0800'>2025年11月28日</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to AI使用技巧（开篇）" href=https://neo-dai.github.io/posts/ai%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BC%80%E7%AF%87/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>健身动作库</h2></header><div class=entry-content><p>杠铃卧推 目标肌群: 胸大肌（整体）、肱三头肌、三角肌前束 动作流程: 平躺于卧推凳，双脚踩实地面，肩胛骨后收下沉。 握距稍宽于肩，起杠后将杠铃悬停于肩部正上方。 吸气，控制速度下放杠铃至胸骨中部（乳头连线处），前臂垂直地面。 呼气，发力将杠铃推回起始位置。 核心点/易错点: 核心稳定: 保持腹部收紧，不要过度弓腰。 手腕中立: 避免手腕过度后折，以免压迫腕关节。 上斜哑铃卧推 目标肌群: 上胸肌、三角肌前束 动作流程: 调节椅背至30°-45°。 双手持哑铃举至肩上方，掌心朝前。 吸气慢放，感受上胸拉伸；呼气推起至手臂伸直（微屈）。 核心点/易错点: 角度选择: 角度过大（>60°）会变成推肩。 前臂垂直: 任何时候前臂都应垂直于地面。 双杠臂屈伸 目标肌群: 胸大肌下束（前倾）、肱三头肌（直立） 动作流程: 双手握杠，身体悬空。 屈肘下放身体，直至大臂平行地面。 撑起身体还原。 核心点/易错点: 保护肩部: 下放不要过深，以免拉伤肩关节。 目标区分: 身体前倾、手肘外展侧重练胸；身体直立、夹肘侧重练臂。 哑铃过头臂屈伸 目标肌群: 肱三头肌（长头） 动作流程: 坐姿或站姿，双手托住哑铃一端举过头顶。 大臂夹紧头部两侧，屈肘将哑铃下放至颈后。 伸直手臂还原。 核心点/易错点: 大臂固定: 全程大臂尽量不动，不要向外打开。 腰椎保护: 核心收紧，避免肋骨外翻和塌腰。 绳索臂屈伸 目标肌群: 肱三头肌（侧重外侧头、内侧头） 动作流程: 站立，双脚与肩同宽，身体微前倾。 大臂夹紧身体两侧固定。 呼气，伸直手臂向下压，直至手臂完全伸直。 吸气，缓慢还原至小臂平行地面。 核心点/易错点: 只动小臂: 避免大臂前后晃动借力。 顶峰收缩: 动作底部手腕外旋（若用绳索），挤压三头肌。 平板蝴蝶收腹 目标肌群: 腹直肌 动作流程: 平躺，脚掌相对（呈蝴蝶状），膝盖向外打开。 双手置于头后或胸前。 呼气卷起上背部，吸气还原。 核心点/易错点: 消除借力: 蝴蝶腿姿势可减少髂腰肌借力，更孤立腹肌。 不要抱头: 避免双手用力拉拽颈部。 卷腹 目标肌群: 腹直肌上部 动作流程: 平躺，屈膝，双脚踩地。 呼气，依靠腹肌收缩将肩胛骨拉离地面。 吸气，缓慢下放。 核心点/易错点: 幅度控制: 不需要坐起，只需卷起上背部。 颈部放松: 下巴微收，视线看向膝盖方向。 坐姿划船 目标肌群: 背阔肌、中下斜方肌、菱形肌 动作流程: 坐于器械上，脚踩踏板，膝盖微屈。 保持背部挺直，将把手拉向腹部。 感受背部肌群夹紧，缓慢还原。 核心点/易错点: 先肩后手: 启动时先做肩胛后缩，再屈肘拉动。 避免晃动: 躯干保持稳定，不要过度后仰借力。 杠铃划船 目标肌群: 背阔肌（厚度）、大圆肌、三角肌后束 动作流程: 俯身，背部挺直与地面呈45°或更低。 双手正手或反手握杠。 将杠铃沿大腿拉向腹部位置。 核心点/易错点: 腰背挺直: 严禁弓腰，防止腰椎受伤。 手肘贴身: 拉起时手肘尽量贴近身体。 窄距下拉 目标肌群: 背阔肌下部 动作流程: 坐于下拉器械，使用V柄或窄握。 挺胸，将把手拉至上胸部。 控制回放速度。 核心点/易错点: 挺胸沉肩: 全程保持挺胸，下拉时肩膀下沉。 挤压背部: 动作底部用力挤压背阔肌。 哑铃划船 目标肌群: 单侧背阔肌 动作流程: 单手单膝支撑于长凳，背部平直。 另一手持哑铃，自然下垂。 呼气，将哑铃拉向髋部方向。 核心点/易错点: 划弧线: 哑铃运动轨迹是向后上方的弧线，而不是直上直下。 躯干稳定: 避免身体随动作扭转。 哑铃弯举 目标肌群: 肱二头肌 动作流程: 站立或坐姿，掌心向前。 大臂固定，屈肘将哑铃举起。 顶峰收缩后缓慢下放。 核心点/易错点: 避免摇晃: 不要利用身体惯性甩起哑铃。 离心控制: 下放过程要慢，抗阻力。 锤式弯举 目标肌群: 肱肌、肱二头肌外侧、肱桡肌 动作流程: 掌心相对（对握）。 保持掌心相对姿势，屈肘举起哑铃。 核心点/易错点: 手腕锁定: 手腕保持中立，不要弯曲。 增加厚度: 此动作对增加手臂正面视觉宽度很有效。 集中弯举 目标肌群: 肱二头肌（肌峰） 动作流程: 坐姿，双腿分开，持铃手的大臂后侧抵住同侧大腿内侧。 孤立发力弯举哑铃。 核心点/易错点: 完全孤立: 借助大腿固定大臂，彻底消除借力。 顶峰挤压: 在最高点停顿1-2秒。 深蹲 目标肌群: 股四头肌、臀大肌、核心 动作流程: 杠铃置于斜方肌上，双脚略宽于肩。 屈髋屈膝下蹲，膝盖方向与脚尖一致。 蹲至大腿平行地面或更低，发力站起。 核心点/易错点: 膝盖指向: 严禁膝盖内扣。 背部挺直: 保持脊柱中立，不要通过弯腰来达到下蹲深度。 坐姿腿屈伸 目标肌群: 股四头肌（刻画线条） 动作流程: 调整器械，使膝关节对准转轴。 呼气，股四头肌发力将小腿踢直。 吸气缓慢还原。 核心点/易错点: 勾脚尖: 动作过程中保持勾脚尖可增加肌肉收缩感。 不要锁死: 膝盖伸直时保留微屈，保护关节。 腿举 目标肌群: 股四头肌、臀大肌（取决于脚位） 动作流程: 坐入器械，背部紧贴靠背。 双脚蹬板，解锁保险。 屈膝下放至大小腿呈90°，蹬起。 核心点/易错点: 臀部贴紧: 蹬起时臀部不要离开座垫。 膝盖微屈: 顶部不要完全锁死膝盖。 站姿杠铃推举 目标肌群: 三角肌前束、中束，核心 动作流程: 杠铃置于上胸，双手略宽于肩。 收紧臀腹，将杠铃垂直推举过头顶。 头部在杠铃过额头后略微前探。 核心点/易错点: 核心收紧: 避免过度后仰变成上斜卧推。 轨迹垂直: 杠铃运动轨迹应垂直于地面。 哑铃推肩 目标肌群: 三角肌前束、中束 动作流程: 坐姿，双手持铃举至双耳旁。 呼气推举至头顶，哑铃互不触碰。 吸气下放至大臂平行地面或略低。 核心点/易错点: 手肘朝前: 手肘略微朝前，不要完全向两侧打开（保护肩关节）。 行程完整: 下放要充分，不要只做半程。 侧平举 目标肌群: 三角肌中束（肩宽关键） 动作流程: 站立微前倾，双手持铃垂于身前。 肘部微屈，以肩为轴将哑铃向两侧举起。 举至大臂与地面平行即可。 核心点/易错点: 倒水姿势: 想象像倒水一样，小拇指略高于大拇指（内旋），但需注意肩峰撞击风险，新手可保持平举。 手肘引导: 是手肘带动小臂和哑铃，而不是手腕用力挑起。 俯身飞鸟 目标肌群: 三角肌后束 动作流程: 俯身至躯干接近平行地面。 像大鹏展翅一样将哑铃向两侧后方举起。 核心点/易错点: 不要夹背: 主要是肩后束发力，过度夹背会练到斜方肌。 控制惯性: 避免利用身体起伏甩动哑铃。 坐姿髋外展 目标肌群: 臀中肌、臀小肌 动作流程: 坐于器械，大腿外侧贴挡板。 用臀部力量将双腿向外打开。 核心点/易错点: 躯干位置: 身体前倾可更多刺激臀大肌上部，后靠更多刺激臀中肌。 坐姿髋内收 目标肌群: 大腿内收肌群 动作流程: 坐于器械，大腿内侧贴挡板。 用大腿内侧力量将双腿向内夹紧。 核心点/易错点: 控制回放: 离心阶段要控制速度，不要让配重片猛烈撞击。 哑铃卧推 目标肌群: 胸大肌（特别是中缝和整体厚度） 动作流程: 平躺，双手持铃，掌心朝前。 下放至胸部两侧，感受拉伸。 推起至顶点，哑铃靠拢但不触碰。 核心点/易错点: 活动范围: 相比杠铃，哑铃下放更深，拉伸感更强。 顶部挤压: 推起时想象二头肌去触碰胸肌。 上斜哑铃飞鸟 目标肌群: 上胸肌（中缝） 动作流程: 上斜凳，掌心相对。 手臂微屈固定，像抱大树一样向两侧打开。 胸肌发力将哑铃抱回上方。 核心点/易错点: 肘部角度: 全程保持肘部微屈固定，不要变伸缩手臂（变成卧推）。 拉伸感: 底部充分拉伸，但不要过度以免伤肩。 器械推胸 目标肌群: 胸大肌 动作流程: 调整座椅高度，使握把位于中胸高度。 挺胸，推起握把。 核心点/易错点: 安全稳定: 适合新手寻找胸肌发力感，且较安全。 肩部固定: 即使推到最远端，肩膀也要贴在椅背上，不要送肩。 哑铃臂屈伸 (仰卧) 目标肌群: 肱三头肌 动作流程: 平躺，双手持铃举起，掌心相对。 屈肘将哑铃下放至耳侧或额头上方。 伸直手臂还原。 核心点/易错点: 大臂角度: 大臂可微向后倾斜，保持三头肌持续张力。 肘部收紧: 避免肘部过度外张。 绳索弯举 目标肌群: 肱二头肌 动作流程: 龙门架低位滑轮，双手握杆。 站立弯举。 核心点/易错点: 持续张力: 绳索的特点是全程都有张力，顶峰收缩效果好。 上斜哑铃弯举 目标肌群: 肱二头肌（长头） 动作流程: 躺在上斜凳（45°-60°）上。 手臂自然下垂，进行弯举。 核心点/易错点: 拉伸长头: 利用身后位置充分拉伸二头肌长头。 肘部稳定: 肘部需始终指向地面，不要前移。 牧师凳锤式弯举 目标肌群: 肱肌、肱桡肌 动作流程: 腋下卡住牧师凳边缘。 竖握哑铃（锤式）进行弯举。 核心点/易错点: 无法借力: 此动作完全孤立，重量选轻一点。 哑铃箭步蹲 目标肌群: 股四头肌、臀大肌 动作流程: 双手持铃垂于体侧。 向前迈一大步下蹲，前后腿均呈90°。 前腿发力蹬回。 核心点/易错点: 重心控制: 躯干直立侧重股四，前倾侧重臀部。 膝盖保护: 前脚膝盖不要过度超过脚尖，后腿膝盖不触地。 硬拉 (传统) 目标肌群: 后链肌群（背部、臀部、腘绳肌） 动作流程: 杠铃贴小腿，双脚与髋同宽。 屈髋屈膝握杆，背部挺直收紧。 脚后跟蹬地，髋膝同时伸展将杠铃拉起。 核心点/易错点: 启动: 想象是用脚蹬离地面，而不是用手拉起杠铃。 脊柱中立: 全程严禁龟背（弓腰）。 哑铃直腿硬拉 (RDL) 目标肌群: 腘绳肌（大腿后侧）、臀大肌 动作流程: 微屈膝固定（并非完全直腿）。 屈髋（屁股向后撅），哑铃沿腿部前侧下放。 感受大腿后侧拉伸，臀部发力顶髋回正。 核心点/易错点: 屈髋主导: 动作是屁股前后动，不是上下蹲。 杠铃贴腿: 哑铃/杠铃始终贴着腿上下，减少腰部压力。 阿诺德推肩 目标肌群: 三角肌前、中束 动作流程: 起始位掌心朝向面部。 外展肩部的同时旋转手腕推起。 终点位掌心朝前。 核心点/易错点: 流畅旋转: 推举与旋转同步进行。 行程更长: 相比普通推肩刺激范围更广，但重量不宜过大。 半俯身侧平举 目标肌群: 三角肌侧后方 动作流程: 一手抓固定物，身体略微倾斜。 另一手持铃向侧上方举起。 核心点/易错点: 解决借力: 倾斜身体改变了阻力力矩，能更好刺激三角肌中束起始阶段。 蝴蝶机反向飞鸟 目标肌群: 三角肌后束 动作流程: 面向蝴蝶机坐，双手反向握把。 向后打开双臂，直至与背部成一直线。 核心点/易错点: 不要缩颈: 保持沉肩，避免斜方肌代偿。 手肘微屈: 手臂不要完全伸直锁死。</p></div><footer class=entry-footer><span title='2025-11-24 20:19:18 +0800 +0800'>2025年11月24日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to 健身动作库" href=https://neo-dai.github.io/posts/%E5%81%A5%E8%BA%AB/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MapReduce：大型集群上的简化数据处理(英译中)</h2></header><div class=entry-content><p>本文是 《MapReduce：Simplified Data Processing on Large Clusters》 论文的中文翻译。
该论文是分布式系统领域的里程碑式工作，提出了 MapReduce 编程模型，极大地简化了大规模数据处理任务的开发难度。MapReduce 与 GFS（Google File System）和 Bigtable 并称为“Google三驾马车”，成为支撑 Google 大规模数据处理和存储的核心基础设施之一。无论你是刚入门分布式系统开发，还是希望深入理解现代大数据处理的核心思想，深入阅读和理解此文都具有重要的学习价值。
特别需要注意的是，这篇论文也是 MIT 6.824 第一讲（Lecture 1: Introduction）的核心阅读材料之一，对于打好分布式系统理论与工程实践的基础极为关键。
【免责声明】
本译文仅供个人学习与学术交流，严禁用于任何商业用途。如涉及版权问题，请即联系以便及时处理和删除。
原文链接：https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf
MapReduce：大型集群上的简化数据处理 Jeffrey Dean and Sanjay Ghemawat
jeff@google.com, sanjay@google.com
Google, Inc.
摘要 (Abstract) MapReduce is a programming model and an associ-ated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. Many real-world tasks can be expressed in this model, as shown in the paper.
...</p></div><footer class=entry-footer><span title='2025-11-22 15:44:01 +0800 +0800'>2025年11月22日</span>&nbsp;·&nbsp;<span>23 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to MapReduce：大型集群上的简化数据处理(英译中)" href=https://neo-dai.github.io/posts/mapreduce%E4%B8%AD%E8%AF%91/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[硬核] 分布式系统修炼指南：MIT 6.824 + DDIA 联合通关指南</h2></header><div class=entry-content><p>前言：为什么选择这条路？ 在分布式系统的学习路径中，有两座公认的大山：
理论圣经：《数据密集型应用系统设计》(DDIA) —— 教你"怎么选"、“怎么设计” 实践巅峰：MIT 6.824 (Distributed Systems) —— 教你"怎么做"、“怎么实现” 很多人分开学，结果往往是：看了书觉得懂了，一写代码就崩；或者闷头写代码，却不知道为什么这样设计。
💡 这份计划旨在将理论(DDIA)与实践(MIT 6.824)深度融合，助你从原本的"CRUD工程师"进阶为真正的分布式系统开发者。
0. 准备工作(预备周) 语言基础 MIT 6.824 Labs全程使用Go语言。
Action: 完成A Tour of Go
重点攻克以下Go并发原语：
// 需要熟练掌握的核心概念 - Goroutines // 轻量级线程 - Channels // 协程间通信 - Mutex/RWMutex // 互斥锁和读写锁 - sync.Cond // 条件变量 心态准备 ⚠️ 警告：这不会很容易。Lab 2(Raft)可能会让你怀疑人生，请做好心理准备。
Phase 1: 分布式系统的基石(1-2周) 目标：理解分布式存储的基本形态，习惯RPC编程。
📖 阅读(DDIA) Ch 5: Replication(复制) - 重点理解Leader-based replication，这是GFS和Raft的基础 Ch 1: Reliable, Scalable, Maintainable - 建立宏观概念 💻 课程(MIT 6.824) Lecture: MapReduce, GFS(可以只看讲义/论文，视频选看) Lab 1: MapReduce - 实现一个简单的单词计数器 重点：熟悉RPC框架 难点：适应Debug分布式程序的痛苦 ✅ 阶段目标 理解Master-Worker架构 能够使用Go的RPC库 掌握基本的分布式调试技巧 Phase 2: 核心难关——共识算法Raft(3-5周) 目标：这是整个计划中最难、含金量最高的部分。切勿求快！
...</p></div><footer class=entry-footer><span title='2025-11-21 20:11:37 +0800 +0800'>2025年11月21日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to [硬核] 分布式系统修炼指南：MIT 6.824 + DDIA 联合通关指南" href=https://neo-dai.github.io/posts/%E7%A1%AC%E6%A0%B8-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97mit-6.824-+-ddia-%E8%81%94%E5%90%88%E9%80%9A%E5%85%B3%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LeetCode01 两数之和</h2></header><div class=entry-content><p>题目描述 链接
给定一个整数数组 nums 和一个整数目标值target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
输入：nums = [3,3], target = 6 输出：[0,1]
解题思路 核心思想 使用哈希表来优化查找过程。对于当前遍历到的数nums[i]，我们需要找到target - nums[i]是否在数组中。
算法步骤 创建一个哈希表num_to_index，用于存储数值到索引的映射 遍历数组，对于每个元素nums[i]： 计算补数complement = target - nums[i] 在哈希表中查找complement是否存在 如果存在，返回[num_to_index[complement], i] 如果不存在，将当前数值和索引存入哈希表 遍历结束后返回空数组（题目保证有解，不会执行到这里） 为什么不用暴力解法？ 暴力解法需要两层循环，时间复杂度为O(n²)。而使用哈希表可以将查找时间从O(n)降到O(1)，总体时间复杂度优化到O(n)。
复杂度分析 时间复杂度: O(n)，其中n是数组长度，我们只需要遍历一次数组 空间复杂度: O(n)，哈希表最多需要存储n个元素 代码实现 C++实现 #include "leetcode.h" class Solution { public: vector&lt;int> twoSum(vector&lt;int>& nums, int target) { unordered_map&lt;int, int> num_to_index; for (int i = 0; i &lt; nums.size(); ++i) { int complement = target - nums[i]; // 查找补数是否存在 if (num_to_index.find(complement) != num_to_index.end()) { return {num_to_index[complement], i}; } // 存储当前数值和索引 num_to_index[nums[i]] = i; } return {}; } }; Go实现 package main func twoSum(nums []int, target int) []int { numToIndex := make(map[int]int) for i, num := range nums { complement := target - num // 查找补数是否存在 if idx, found := numToIndex[complement]; found { return []int{idx, i} } // 存储当前数值和索引 numToIndex[num] = i } return []int{} } Python实现 class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ num_to_index = {} for i, num in enumerate(nums): complement = target - num # 查找补数是否存在 if complement in num_to_index: return [num_to_index[complement], i] # 存储当前数值和索引 num_to_index[num] = i return [] Lua实现 function twoSum(nums, target) local num_to_index = {} for i = 1, #nums do local num = nums[i] local complement = target - num -- 查找补数是否存在 if num_to_index[complement] ~= nil then return {num_to_index[complement], i} end -- 存储当前数值和索引 num_to_index[num] = i end return {} end -- 测试代码(LeetCode平台不支持Lua，需手动测试) local nums = {2, 7, 11, 15} local target = 9 local result = twoSum(nums, target) print("输入数组:") for i = 1, #nums do io.write(nums[i] .. " ") end print("\n目标值: " .. target) print("结果索引: " .. result[1] .. ", " .. result[2]) print("验证: nums[" .. result[1] .. "] + nums[" .. result[2] .. "] = " .. nums[result[1]] .. " + " .. nums[result[2]] .. " = " .. (nums[result[1]] + nums[result[2]])) 总结 这道题是哈希表应用的经典例题，核心要点：
...</p></div><footer class=entry-footer><span title='2025-11-21 19:31:34 +0800 +0800'>2025年11月21日</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>neo</span></footer><a class=entry-link aria-label="post link to LeetCode01 两数之和" href=https://neo-dai.github.io/posts/leetcode01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://neo-dai.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://neo-dai.github.io/>Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default",securityLevel:"loose"}),document.querySelectorAll(".mermaid").length>0&&mermaid.run()</script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>